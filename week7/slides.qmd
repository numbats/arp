---
title: ETC4500/ETC5450 Advanced&nbsp;R&nbsp;programming
author: "Week 7: Reactive programming with targets and renv"
format:
  presentation-beamer:
    fontsize: "14pt,t"
    section-titles: false
    knitr:
      opts_chunk:
        dev: "cairo_pdf"
    fig-width: 7.5
    fig-height: 3.5
    include-in-header: ../header.tex
    colorlinks: true
    urlcolor: MonashBlue
    linkcolor: burntorange
---

```{r}
#| label: setup
#| include: false
#| cache: false
source(here::here("setup.R"))
source(here::here("course_info.R"))
```

# Reactive programming

## Regular (imperative) programming

Consider how code is usually evaluated...

```{r, eval = FALSE}
a <- 1
b <- 2
x <- a + b
x
```

What is `x`?

```{r, eval = FALSE}
a <- -1
x
```

What is `x` now?

## Regular (imperative) programming

::: {.callout-tip title="Predictable programming"}
All programming we've seen so far evaluates code in sequential order, line by line.

\hspace{1em}

Since `x` was not re-evaluated, its value stays the same even when its inputs have changed.
:::

<!-- . . . -->

<!-- *Note: this is why it's especially important to ensure code works when ran from top to bottom, since when doing a data analysis we often write and run code more freely!* -->

## Reactive programming

Within a reactive programming paradigm, objects *react* to changes in their inputs and automatically update their value!

. . .

::: {.callout-warning title="Disclaimer"}
Reactive programming is a broad and diverse paradigm, we'll focus only on the basic concepts and how they apply in shiny applications.
:::

## Reactive programming

We can implement *reactivity* with functions & environments.

```{r}
library(rlang)
react <- function(e) new_function(alist(), expr(eval(!!enexpr(e))))
```

We'll learn how this function works later (metaprogramming).

Reactive programming is also smarter about *'invalidation'*, results are **cached and reused** if the inputs aren't changed.

## Reactive programming

How does reactive programming differ?

```{r, eval = FALSE}
a <- 1
b <- 2
y <- react(a + b)
y()
```

What is `y`?

```{r, eval = FALSE}
a <- -1
y()
```

What is `y` now?

## Reactive programming

::: {.callout-tip title="(Un)predictable programming?"}
Reactive programming can be disorienting!

\hspace{1em}

Reactive objects *invalidate* whenever their inputs change, and so its value will be recalculated and stay up-to-date.
:::

## Reactive programming

::: {.callout-caution title="Your turn!"}
<!-- Experiment with using `react()` in R. -->

<!-- ```{r} -->
<!-- library(rlang) -->
<!-- react <- function(e) new_function(alist(), expr(eval(!!enexpr(e)))) -->
<!-- ``` -->

```{r, eval = FALSE}
a <- 1
b <- 2
y <- react(a + b)
y()
```

When was `a + b` evaluated?

\vspace{1em}

How does this differ from ordinary (imperative) code?
:::

## Imperative and declarative programming

\fontsize{13}{13}\sf
::: {.callout-note icon=false title="Imperative programming"}
* Specific commands are carried out immediately.
* Usually direct and exact instructions.
* e.g. read in data from this file.
:::

::: {.callout-note icon=false title="Declarative programming"}
* Specific commands are carried out when needed.
* Expresses higher order goals / constraints.
* e.g. make sure this dataset is up to date every time I see it.
:::

## Use cases for reactive programming

\fontsize{13}{13}\sf
::: {.callout-important title="Use-less cases"}
This paradigm is rarely needed or used in R for data analysis.
:::

::: {.callout-tip title="Useful cases"}
Reactive programming is useful for developing user applications (including web apps!).

\vspace{1em}

In R, the shiny package uses reactive programming for writing app interactivity.
:::

# Caching

## Caching: using rds

```{r}
#| eval: false
if (file.exists("results.rds")) {
  res <- readRDS("results.rds")
} else {
  res <- compute_it() # a time-consuming function
  saveRDS(res, "results.rds")
}
```

\pause\vspace*{1cm}

\alert{Equivalently\dots}

```{r}
#| eval: false
res <- xfun::cache_rds(
  compute_it(), # a time-consuming function
  file = "results.rds"
)
```

## Caching: using rds
\fontsize{10}{10}\sf

```{r}
#| label: cache1
#| cache: false
#| freeze: false
compute <- function(...) {
  xfun::cache_rds(rnorm(6), file = "results.rds", ...)
}
compute()
compute()
```

```{r}
#| include: false
#| cache: false
# Need to explicitly remove results.rds for some reason when doing this in quarto
file.remove(here::here("cache/results.rds"))
```

```{r}
#| label: cache2
#| cache: false
#| freeze: false
compute(rerun = TRUE)
compute()
```

## Caching downloads

You often want to prevent downloads of the same data multiple times.

```{r}
#| eval: false
download_data <- function(url) {
  dest_folder <- tempdir()
  sanitized_url <- stringr::str_replace_all(url, "/", "_")
  dest_file <- file.path(dest_folder, paste0(sanitized_url, ".rds"))
  if (file.exists(dest_file)) {
    data <- readRDS(dest_file)
  } else {
    data <- read_tsv(url, show_col_types = FALSE)
    saveRDS(data, dest_file)
  }
  data
}
bulldozers <- download_data("https://robjhyndman.com/data/Bulldozers.csv")
```

## Caching: memoise

Caching stores results of computations so they can be reused.

\fontsize{10}{10}\sf

```{r}
library(memoise)
sq <- function(x) {
  print("Computing square of 'x'")
  x**2
}
memo_sq <- memoise(sq)
memo_sq(2)
memo_sq(2)
```

## Caching: Rmarkdown

````{verbatim}
```{r import-data, cache=TRUE}
d <- read.csv('my-precious.csv')
```

```{r analysis, dependson='import-data', cache=TRUE}
summary(d)
```
````

* Requires explicit dependencies or changes not detected.
* Changes to functions or packages not detected.
* Good practice to frequently clear cache to avoid problems.
* targets is a better solution

## Caching: Quarto

````{verbatim}
```{r}
#| label: import-data
#| cache: true
d <- read.csv('my-precious.csv')
```

```{r}
#| label: analysis
#| dependson: import-data
#| cache: true
summary(d)
```
````

* Same problems as Rmarkdown
* targets is a better solution
