{
  "hash": "82ab6e8e1c9b62bb951607d7de30ba36",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: ETC4500/ETC5450 Advanced&nbsp;R&nbsp;programming\nauthor: \"Week 8: Object-oriented Programming (S3)\"\nformat:\n  presentation-beamer:\n    fontsize: \"14pt,t\"\n    section-titles: false\n    knitr:\n      opts_chunk:\n        dev: \"cairo_pdf\"\n    fig-width: 7.5\n    fig-height: 3.5\n    include-in-header: ../header.tex\n    keep-tex: false\n---\n\n\n\n## Outline\n\n\\vspace*{0.4cm}\n\\tableofcontents\n\n# Object oriented programming\n\n## Object oriented programming\n\n- **Encapsulation**: objects have secret internals that you don't need to understand\n- **Polymorphism**: the same function can do different things to different data as appropriate\n- **Inheritance**: you can take an existing kind of object and make a new, more specialised one\n\nInheritance turns out to be useful mostly for data infrastructure, but encapsulation and polymorphism are generally valuable\n\n## Generic functions and methods\n\nA simple example: `plot`\n\n---\n\n::: {.cell}\n\n```{.r .cell-code}\nplot(trees)\n```\n\n::: {.cell-output-display}\n![](slides_files/figure-beamer/unnamed-chunk-2-1.pdf){fig-pos='H'}\n:::\n:::\n\n---\n\n::: {.cell}\n\n```{.r .cell-code}\nm<-lm(log(Volume)~log(Girth)+log(Height),\n       data=trees)\npar(mfrow=c(2,2),mar=c(3,1,1,1))\nplot(m)\n```\n\n::: {.cell-output-display}\n![](slides_files/figure-beamer/unnamed-chunk-3-1.pdf){fig-pos='H'}\n:::\n:::\n\n---\n\n::: {.cell}\n\n```{.r .cell-code}\nplot(.leap.seconds)\n```\n\n::: {.cell-output-display}\n![](slides_files/figure-beamer/unnamed-chunk-4-1.pdf){fig-pos='H'}\n:::\n:::\n\n---\n\n::: {.cell}\n\n```{.r .cell-code}\nplot(nhtemp)\n```\n\n::: {.cell-output-display}\n![](slides_files/figure-beamer/unnamed-chunk-5-1.pdf){fig-pos='H'}\n:::\n:::\n\n---\n\n### How?\n\n* Giant `switch` statement...\n* ...that gets updated every time you load a package...\n* ???\n\nGeneric functions and methods!\n\n## Object systems\n\nR has **a lot** of object systems\n\n- S3\n- [S3 `vctrs`]\n- S4\n- R6\n- R.oo, proto, R7\n\n---\n\n### S3\n\nMain topic for today\n\n- easy to start writing\n- no safeguards\n- especially good for single-person, small to medium projects\n- can be used for large projects with a lot of attention to documentation and communication\n- limited use of inheritance\n- basis of tidyverse and most of CRAN\n\n---\n\n### S3 `vctrs`\n\nA tidyverse package for making different sorts of vectors\n\n- handles a lot of formatting and subsetting details\n- allows for binary operators\n- useful if you want your vectors in a tibble\n- enforces some safeguards\n\n---\n\n### S4\n\n- more work to start writing\n- objects know their structure\n- enforces object structure\n- better for large-scale collaborative programming\n- better at inheritance\n- basis of Bioconductor\n\n---\n\n### R6\n\n- Supports modifiable (mutable) objects\n   * database connections, files, etc\n   * large data objects we don't want to copy\n   * interfacing to eg tensorflow\n   * shared state between copies of an object\n- not widely used otherwise\n- more similar to other languages\n\n# S3\n## S3\n\n### Back to `plot`\n\n* `plot()` doesn't *do* anything\n* All the work is done by *methods* for different types of object\n* Methods are just ordinary functions\n* When you call `plot`, R calls the appropriate `plot` method\n\n---\n\n### Generic functions\n\n* Generic functions don't *do* anything\n* All the work is done by *methods* for different types of object\n* Methods are just ordinary functions\n    - with declarations in a package `NAMESPACE`\n    - or R can guess based on function name\n\nWhen you call the generic function R calls the appropriate  method\n\n---\n\n### Try these\n\n```\nprint\nmethods(\"print\")\nstats:::print.acf\ntools:::print.CRAN_package_reverse_dependencies_and_views\nplot\nmethods(\"plot\")\nplot.ts\nstats:::plot.lm\n```\n\nAlso, try `methods(\"plot\")` after loading another package\n\n---\n\n### What do we notice?\n\n- `print` functions are all different\n- names start with `print.`, then the sort of thing they print\n- mostly aren't visible just by name\n-\n-\n\n---\n\n### Generic functions\n\n* *methods* that actually do the work 'belong to' *generic functions*\n\n* This is unusual: most popular OOP systems (Java, C++, Python) have methods belonging to data objects\n\n* Important in R because functions are first-class objects (Week 5)\n\n* Useful for functional programming with objects\n\n---\n\n### Classes\n\n- S3 classes are the things that specify which method to use\n- Use `class` to attach a class to an object like a Post-It note\n- That's all\n\n```\nx<-1\nclass(x)<-\"numbat\"\n```\n\n---\n\n#### Try it\n\n```\nprint.numbat <- function(x,...){\n  cat(x,\"numbats\\n\")\n  invisible(x)\n}\n```\n\n---\n\n#### Defining classes\n\n- R doesn't care what `class` you attach to an object\n- **You** have to care\n- `class(x) <- \"lm\"` makes R call `lm` methods on `x`\n- **You** are responsible for these methods being appropriate\n- Documentation is important\n- No real enforcement of encapsulation\n\n---\n\n#### Ways to set up classes\n\n- vectors plus attributes (`ts`, `POSIXct`, matrix)\n- lists plus attributes (`lm`, `data.frame`)\n- environments plus attributes\n\n#### Try it\n\n```\nunclass(.leap.seconds)\nunclass(nhtemp)\nunclass(trees)\nm<-lm(log(Volume)~log(Girth)+log(Height),data=trees)\nstr(m)\n```\n\n---\n\n### Defining classes safely\n\n- Document what all is in a valid object of your class\n- Have a limited set of places where one is created\n- Consider having a pure constructor function (ARP 13.3.1)\n- Consider having a validator function (ARP 13.3.1)\n- Have a user-friendly function to make valid objects\n\nThis is more important if *someone else* might want to make an object from your class\n\n---\n\n### Constructors\n\n- user-friendly: `tibble`, `lm`, `acf`, `svydesign`\n- pure: `new_factor`, `new_difftime` (ARP 13.3.1)\n\nMakes a new object and ensures that it is valid. Stops users creating the object themselves.\n\n---\n\n### Defining methods\n\n- A method should have **the same** arguments as the generic (plus maybe more)\n- The name of the method is `paste(generic,class,sep=\".\")`\n- Less ambiguous: use a package and declare the functions\n    * `S3method(generic, class)` in `NAMESPACE`\n    * `@method generic class` with `devtools`\n- `sloop::ftype` tells you about the type of a function\n- `sloop::s3_get_method` or `getAnywhere` finds methods even if they're hidden\n\n---\n\n### `default` methods\n\nCalled when there is no specific method for the object (no class, or no matching class)\n\n- `mean.default`\n- `summary.default`\n- `head.default`\n\n---\n\n### Adding methods to your class\n\nNo *rules* on which methods, but informal standards\n\n- Start with `print`, `[`\n- `summary` for more information\n- `plot` or `image` if possible (`ggplot` methods take more work)\n- `coef`, `vcov`, maybe `logLik` and `AIC` for models\n- `resid` for models with residuals\n\n---\n\n### Base S3 classes\n\n- The class for method choice isn't just `class(x)` for base types\n- Use `sloop::s3_class` to be sure\n\n```\n> s3_class(1)\n[1] \"double\"  \"numeric\"\n> s3_class(matrix(1,1,1))\n[1] \"matrix\"  \"double\"  \"numeric\"\n> class(1)\n[1] \"numeric\"\n> class(matrix(1,1,1))\n[1] \"matrix\" \"array\"\n```\n\n---\n\n### Ambiguous cases\n\n- `t` is a generic\n- `t.test` is a generic\n- `t.test.formula` is a method for `t.test`\n- `t.data.frame` is a method for `t`\n- `list` is not generic\n- `list.files` isn't a method\n\nAvoid using `.` as a word separator in function names that aren't methods. Use `camelCase` or `snake_case` or some other consistent approach\n\n---\n\n### Defining generics\n\nA typical generic function includes **only** a call to `UseMethod`\n\n::: {.cell}\n\n```{.r .cell-code}\nprint\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nfunction (x, ...) \nUseMethod(\"print\")\n<bytecode: 0x5f34de7fea90>\n<environment: namespace:base>\n```\n\n\n:::\n:::\n\n---\n\n### Dispatch on another argument\n\nSpecify which argument to use for choosing the method (default is the first)\n\n```\n> survey:::svymean\nfunction (x, design, na.rm = FALSE, ...)\n{\n    .svycheck(design)\n    UseMethod(\"svymean\", design)\n}\n```\n\n---\n\n### Inheritance\n\nThe `class` attribute of an object can have multiple elements\n\n- `UseMethod()` uses the first method that matches, or `default`\n- `NextMethod()` uses the next method that matches\n\n---\n\n### Polite conduct\n\n- if you define a new generic, you can define methods for new and existing classes\n- if you define a new class, you can define methods for new and existing generics\n- don't define methods for someone else's class and generic (ask them)\n- try not to define a generic with the same name as an existing one\n\n# S3 `vctrs`\n\n## S3 `vctrs`\n\nA package for defining new S3 vectors\n\n- makes it easy to have them as `tibble` columns\n- requires a *pure constructor* to make new objects, so they will all be valid\n- supports *double dispatch* for binary operators (eg: +,-)\n- has a complicated but reliable system for type conversion\n- requires a lot of method definitions to get started\n\n[vctrs.r-lib.org](https://vctrs.r-lib.org)\n\n---\n\n## An example: S3 and `vctrs`\n\nThe `rimu` package represents multiple-response questions\n\n```\nremotes::install_github(\"tslumley/rimu\")\n```\n---\n\n```\ndata(usethnicity)\nrace<-as.mr(strsplit(as.character(usethnicity$Q5),\"\"))\nrace<-mr_drop(race,\" \")\nmtable(race)\nhispanic<-as.mr(usethnicity$Q4==1,\"Hispanic\")\nethnicity<-mr_union(race,hispanic)\nplot(ethnicity)\ne_S3<-ethnicity[101:120]\ne_vctrs<-as.vmr(e_S3,na.rm=TRUE)\n```\n\n---\n\n#### Inheritance\n\n```\nmr_union<-function(x,y,...) UseMethod(\"mr_union\")\n\nmr_union.default<-function(x,y,...){\n  x<-as.mr(x)\n  y<-as.mr(y)\n  if (length(x)!=length(y))\n    stop(\"different numbers of observations in x and y\")\n\n.....\n}\n```\n\n---\n\n```\nmr_union.vmr<-function(x,y,...) {\n    r<-NextMethod()\n    as.vmr(r)\n}\n```\n\n---\n\n#### Encapsulation\n\n- base S3 version is matrix of logical, plus levels attribute\n    * works in `data.frame`\n- vctrs S3 version is list of vectors of strings\n    * works in `tibble`\n\n---\n\n#### Pure constructor\n\n```\nnew_vmr <- function(x,levels=unique(do.call(c,x))) {\n  vctrs::new_list_of(x, ptype = character(),\n  class = \"vmr\", levs=levels)\n}\n```\n\n---\n\n#### 'helper' functions\n\n```\n> methods(\"as.mr\")\n[1] as.mr.character*  as.mr.data.frame* as.mr.default*\n[4] as.mr.factor*     as.mr.list*       as.mr.logical*\n[7] as.mr.mr*         as.mr.ms*         as.mr.vmr*\n\n> methods(\"as.vmr\")\n[1] as.vmr.default* as.vmr.mr*\n```\n\n# S4\n## S4\n\nS4 requires classes and methods to be registered in R code (not just in packages)\n\n- `setClass` defines the structure of a class\n- `new` creates a new object from a class\n- `setMethod` defines a method\n\nIt's possible to ask an object what methods it supports and get a reliable response.\n\nS4 also allows multiple inheritance and multiple dispatch\n\n---\n\n### Bioconductor\n\n- Package system for high-throughput molecular biology\n- Large data\n- Structured data\n- Annotated data\n- New data types/structures all the time\n\nIt needs consistent infrastructure and large-scale collaboration: S4\n\n[bioconductor.org](https://bioconductor.org)\n\n---\n\n### Multiple dispatch\n\nChoosing a method based on the class of more than one argument\n\n- not very often useful\n- important for matrices\n- can be useful for plots\n\n---\n\n### Multiple inheritance\n\n`AnnDbObjBimap` is a class for storing look-up tables between different genomic identifiers (eg from different manufacturers)\n\nIt is\n\n- (by purpose) a two-way lookup object (`BiMap`)\n- (by construction) an object containing a SQLite database (`DbObj`)\n\nso it inherits generic functions from both these parents\n\n# R6\n\n## R6\n\nRemember function factories from last week?\n\n- Create a function closure with useful variables in its environment\n- These variables are visible inside the function\n\nNow do this with\n\n- multiple variables in the shared environment\n- multiple functions inheriting this environment\n- allow the shared variables to be modified\n\n---\n\n#### R6 is good for...\n\n- large data objects, to reduce copying\n- external objects that R can't just copy (database connections, files,... )\n- shared state such as games\n\nR6 is more similar to C++/Java/Python OOP. It doesn't really support functional programming\n\n[R6.r-lib.org](https://r6.r-lib.org/articles/Introduction.html)\n",
    "supporting": [
      "slides_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": null,
    "postProcess": false
  }
}