{
  "hash": "fc87f35735adba77a1619f4337c4e26f",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: ETC4500/ETC5450 Advanced&nbsp;R&nbsp;programming\nauthor: \"Week 8: Object-oriented Programming\"\nformat:\n  presentation-beamer:\n    fontsize: \"14pt,t\"\n    section-titles: false\n    knitr:\n      opts_chunk:\n        dev: \"cairo_pdf\"\n    fig-width: 7.5\n    fig-height: 3.5\n    include-in-header: ../header.tex\n    keep-tex: false\n---\n\n\n\n## Outline\n\n\\vspace*{0.4cm}\n\\tableofcontents\n\n# Programming paradigms\n\n## Programming paradigms\n\n::: {.callout-note icon=false title=\"Functional programming (W5)\"}\n* Functions are created and used like any other object.\n* Output should only depend on the function's inputs.\n:::\n\n. . .\n\n::: {.callout-note icon=false title=\"Literate programming (W6)\"}\n* Natural language is interspersed with code.\n* Aimed at prioritising documentation/comments.\n* Now used to create reproducible reports/documents.\n:::\n\n## Programming paradigms\n\n::: {.callout-note icon=false title=\"Reactive programming (W7)\"}\n* Objects are expressed using code based on inputs.\n* When inputs change, the object's value updates.\n:::\n\n. . .\n\n::: {.callout-note icon=false title=\"Object-oriented programming (W8-W9)\"}\n* Functions are associated with object types.\n* Methods of the same 'function' produce object-specific output.\n:::\n\n# Object oriented programming\n\n## Object oriented programming\n\n\n- **Encapsulation**: Bundles data and methods in a class, restricting access to internal details.\n\n- **Abstraction**: Simplifies complexity by exposing only essential features of an object.\n\n- **Polymorphism**: Allows the same function to operate differently on different object types.\n\n- **Inheritance**: Enables a new class to inherit properties and behaviors from an existing class.\n\n## Object oriented programming\n\n**Inheritance** is primarily useful for structuring data infrastructure by allowing reuse and extension of existing classes.\n\n**Encapsulation** helps protect object integrity by restricting access to internal states.\n\n**Polymorphism** enables flexibility by allowing a single interface to operate on various data types. \n\n**Abstraction** simplifies complexity by highlighting essential features, making systems easier to understand and use.\n\n## Generic functions and methods\n\nA simple example: `plot`\n\n## Generic functions and methods\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplot(trees)\n```\n\n::: {.cell-output-display}\n![](slides_files/figure-beamer/unnamed-chunk-1-1.pdf){fig-pos='H'}\n:::\n:::\n\n\n## Generic functions and methods\n\n\n::: {.cell}\n\n```{.r .cell-code}\nm<-lm(log(Volume)~log(Girth)+log(Height),\n       data=trees)\npar(mfrow=c(2,2),mar=c(3,1,1,1))\nplot(m)\n```\n\n::: {.cell-output-display}\n![](slides_files/figure-beamer/unnamed-chunk-2-1.pdf){fig-pos='H'}\n:::\n:::\n\n\n## Generic functions and methods\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplot(.leap.seconds)\n```\n\n::: {.cell-output-display}\n![](slides_files/figure-beamer/unnamed-chunk-3-1.pdf){fig-pos='H'}\n:::\n:::\n\n\n## Generic functions and methods\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplot(nhtemp)\n```\n\n::: {.cell-output-display}\n![](slides_files/figure-beamer/unnamed-chunk-4-1.pdf){fig-pos='H'}\n:::\n:::\n\n\n## Generic functions and methods\n\n### How does `plot()` work?\n\n* Giant `switch` statement...\n* Lots of `if` statements...\n* How does the behaviour update when you load packages?\n* ???\n\n. . .\n\nS3 generic functions and methods!\n\n## Object systems\n\nR has **a lot** of object systems\n\n- S3\n- [S3 `vctrs`]\n- S4\n- R6\n- R.oo, proto, ggproto,\n- R7\n- S7\n\n\n## Object oriented programming\n\n::: {.callout-note icon=false title=\"S3\"}\n* The OO system used by most of CRAN.\n* Very simple (and 'limited') compared to other systems.\n:::\n\n. . .\n\n::: {.callout-note icon=false title=\"vctrs\"}\n* Builds upon S3 to make creating vectors easier.\n* Good practices inherited by default.\n:::\n\n## Object oriented programming\n\n::: {.callout-note icon=false title=\"S4\"}\n* Formal class definitions with validation.\n* Supports multiple inheritance and method dispatch.\n:::\n\n. . .\n\n::: {.callout-note icon=false title=\"S7\"}\n* Planned to be the successor of S3 and S4.\n* More general than S3, but still easy to use.\n:::\n\n\n## Object oriented programming\n\n::: {.callout-note icon=false title=\"R6\"}\n* Provides reference semantics for mutable objects.\n* Simple and efficient compared to reference classes.\n:::\n\n. . .\n\n::: {.callout-note icon=false title=\"ggproto\"}\n* Used in ggplot2 for extensibility.\n* Supports inheritance and method overloading.\n:::\n\n# S3\n\n## S3\n\nMain topic for today\n\n- easy to start writing\n- no safeguards\n- especially good for simple, small-medium projects\n- can be used for large projects with a lot of attention to documentation and communication\n- limited use of inheritance\n- basis of tidyverse and most of CRAN\n\n## S3 with `vctrs`\n\nA helpful package for making different sorts of S3 vectors\n\n- handles a lot of formatting and subsetting details\n- allows for binary operators\n- useful if you want your vectors in a tibble\n- enforces some safeguards\n\nWe'll learn more about `vctrs` next week!\n\n<!-- ## S4 -->\n\n<!-- - more work to start writing -->\n<!-- - objects know their structure -->\n<!-- - enforces object structure -->\n<!-- - better for large-scale collaborative programming -->\n<!-- - better at inheritance -->\n<!-- - basis of Bioconductor -->\n\n<!-- ## R6 -->\n\n<!-- - Supports modifiable (mutable) objects -->\n<!--    * database connections, files, etc -->\n<!--    * large data objects we don't want to copy -->\n<!--    * interfacing to eg tensorflow -->\n<!--    * shared state between copies of an object -->\n<!-- - not widely used otherwise -->\n<!-- - more similar to other languages -->\n\n## S3\n\nBack to the `plot` function...\n\n* `plot()` doesn't *do* anything\n* All the work is done by *methods* for different *classes*\n* Methods are just ordinary functions\n* When you call `plot`, R calls the appropriate `plot` method\n\n## S3: Generic functions\n\n* Generic functions don't *do* anything\n* All the work is done by *methods* for different types of object\n* Methods are just ordinary functions\n    - with declarations in a package `NAMESPACE`\n    - or R can guess based on function name\n\nWhen you call the generic function R calls the appropriate  method\n\n## S3: Generics and methods\n\n::: {.callout-caution title=\"Your turn!\"}\nInvestigate these functions.\n\n```r\nprint\nmethods(\"print\")\nstats:::print.acf\ntools:::print.CRAN_package_reverse_dependencies_and_views\nplot\nmethods(\"plot\")\nplot.ts\nstats:::plot.lm\n```\n\nHow do generic functions relate to methods?\n\nAlso, try `methods(\"plot\")` after loading another package.\n:::\n\n<!-- ### What do we notice? -->\n\n<!-- - `print` functions are all different -->\n<!-- - names start with `print.`, then the sort of thing they print -->\n<!-- - mostly aren't visible just by name -->\n\n\n## S3: Classes\n\n* S3 classes are attributes that specify which method to use\n\n* The `class()` function can access (and modify) an object's class\n\n* Classed S3 objects are typically produced with `structure()`\n\n\nFor example,\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- structure(83, class = \"grade\")\nclass(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"grade\"\n```\n\n\n:::\n\n```{.r .cell-code}\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 83\nattr(,\"class\")\n[1] \"grade\"\n```\n\n\n:::\n:::\n\n\n\n## S3: Methods\n\n* *methods* that actually do the work 'belong to' *generic functions*\n\n* This is unusual: most other OOP systems (Java, C++, Python) have methods belonging to data objects\n\n* Important in R because functions are first-class objects (Week 5)\n\n* Useful for functional programming with objects\n\n## S3: Creating a method\n\n\n::: {.cell}\n\n```{.r .cell-code}\nprint.grade <- function(x, ...){\n  letter <- if (x < 50) \"N\"\n  else if (x < 60) \"P\"\n  else if (x < 70) \"C\"\n  else if (x < 80) \"D\"\n  else \"HD\"\n  cat(x,\" [\", letter, \"]\", sep = \"\")\n  invisible(x)\n}\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n83 [HD]\n```\n\n\n:::\n:::\n\n\n## Creating an S3 generic\n\nS3 generics are work like any ordinary function, but they include `UseMethod()` which calls the appropriate method.\n\n::: {.callout-caution title=\"Your turn!\"}\nCreate an S3 generic called \"reverse\".\n\nThis function will reverse objects. For example,\n\n* `reverse(\"stressed\")` becomes `\"desserts\"`,\n* `reverse(7919)` becomes `9197`,\n* `reverse(1.9599)` becomes `9959.1`.\n:::\n\n## Writing S3 methods\n\nAn S3 method is an ordinary function with some constraints:\n\n* The function's name is of the form `<generic>.<class>`,\n* The function's arguments match the generic's arguments,\n* The function is registered as an S3 method (for packages).\n\nThis looks like:\n\n```r\n#' Documentation for the method\n#' @method <generic> <class>\n<generic>.<class> <- function(<generic args>, <method args>, ...) {\n  # The code for the method\n}\n```\n\n## Writing S3 methods\n\n::: {.callout-caution title=\"Your turn!\"}\nWrite methods for reversing `character`, `integer`, and `double` objects.\n\n* `reverse(\"stressed\")` becomes `\"desserts\"`,\n* `reverse(7919L)` becomes `9197L`,\n* `reverse(1.9599)` becomes `9959.1`.\n\n*Hint: `stringi::stri_reverse()` will reverse a string.*\n\n*The `integer` and `double` methods should return an integer and double respectively.*\n:::\n\n## S3: `.default` methods\n\nDefault methods are called when there is no specific method for the object (no class, or no matching class).\n\nSome examples include:\n\n- `mean.default`\n- `summary.default`\n- `head.default`\n\n## Writing S3 defaults\n\nWhat if we tried to reverse the current date; `reverse(Sys.Date())`?\n\n. . .\n\n::: {.callout-caution title=\"Your turn!\"}\n\nQuestion: what should the default behaviour be?\n\n:::\n\n. . .\n\n* Raise an error?\n* Return a reversed string?\n* Something else entirely?\n\n## S3: Defining classes\n\nThe S3 class system is simple!\n\n- R doesn't care what `class` you attach to an object\n- **You** have to care\n- `class(x) <- \"lm\"` makes R call `lm` methods on `x`\n- **You** are responsible for these methods being appropriate\n- Documentation is important\n- No real enforcement of encapsulation\n\n## S3: Classed objects\n\nYou can class any object, including:\n\n- vectors plus attributes (`ts`, `POSIXct`, matrix)\n- lists plus attributes (`lm`, `data.frame`)\n- environments plus attributes\n\n::: {.callout-caution title=\"Your turn!\"}\nUse `unclass()` and `str()` to explore classed objects, e.g.:\n\n```r\nunclass(.leap.seconds)\nunclass(nhtemp)\nunclass(trees)\nm<-lm(log(Volume)~log(Girth)+log(Height),data=trees)\nstr(m)\n```\n:::\n\n<!-- ### Defining classes safely -->\n\n<!-- - Document what all is in a valid object of your class -->\n<!-- - Have a limited set of places where one is created -->\n<!-- - Consider having a pure constructor function (ARP 13.3.1) -->\n<!-- - Consider having a validator function (ARP 13.3.1) -->\n<!-- - Have a user-friendly function to make valid objects -->\n\n<!-- This is more important if *someone else* might want to make an object from your class -->\n\n## S3: Constructors functions\n\nThese functions return classed S3 objects. They should handle input validation and be user-friendly.\n\nConstructor functions typically come in two forms:\n\n- complex: `tibble`, `lm`, `acf`, `svydesign`\n- pure: `new_factor`, `new_difftime`\n\nPure constructor functions simply validate inputs and produce the classed object, while complex constructor functions involve calculations.\n\n<!-- ## Creating your own S3 objects -->\n\n<!-- S3 methods are *(mostly)* dispatched based on the `class()`. -->\n\n<!-- ```{r} -->\n<!-- class(\"stressed\") -->\n<!-- class(7919L) -->\n<!-- class(1.9599) -->\n<!-- ``` -->\n\n<!-- ## Creating your own S3 objects -->\n\n<!-- To create an S3 object, we add a class to an object. -->\n\n<!-- This is usually done with `structure()`, for example: -->\n\n<!-- \\fontsize{10}{10}\\sf -->\n<!-- ```{r} -->\n<!-- e <- structure(list(numerator = 2721, denominator = 1001), class = \"fraction\") -->\n<!-- e -->\n<!-- ``` -->\n\n## Creating your own S3 objects\n\nThe `structure()` function is usually used within packages.\n\n* `lm()` returns a list with class `\"lm\"`, and\n* `tibble()` returns a list classed `\"tbl_df\"`, `\"tbl\"`, and `\"data.frame\"`.\n\n. . .\n\n::: {.callout-caution title=\"Your turn!\"}\n\nCreate `fraction()`, which returns `fraction` objects.\n\nThe underlying data type is a list containing two vectors for the two arguments: `numerator` and `denominator`.\n\nThis function should check that the inputs are suitable.\n:::\n\n## Creating your own S3 objects\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfraction <- function(numerator, denominator) {\n  if (!is.numeric(numerator) || !is.numeric(denominator)) {\n    stop(\"Both numerator and denominator must be numeric.\")\n  }\n  if (denominator == 0) {\n    stop(\"Denominator cannot be zero.\")\n  }\n  \n  structure(\n    list(numerator = numerator, denominator = denominator),\n    class = \"fraction\"\n  )\n}\n```\n:::\n\n\n\n## Creating your own S3 objects\n\nThe `fraction` class doesn't yet have any methods, so it inherits methods from its list type.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ne <- fraction(numerator = 2721, denominator = 1001)\nprint(e)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$numerator\n[1] 2721\n\n$denominator\n[1] 1001\n\nattr(,\"class\")\n[1] \"fraction\"\n```\n\n\n:::\n:::\n\n\n## Creating your own S3 objects\n\nUsually we would create a method for printing S3 objects.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nprint.fraction <- function(x, ...) {\n  paste(x$numerator, x$denominator, sep = \"/\")\n}\nprint(e)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"2721/1001\"\n```\n\n\n:::\n:::\n\n\n## Creating your own S3 objects\n\n::: {.callout-caution title=\"Your turn!\"}\nCreate a `reverse()` method for the `fraction` object class, which inverts the numerator and denominator.\n\n\\vspace{1em}\n\n*Finished early?*\n\nWrite a method for converting a `fraction` into a number.\n:::\n\n\n\n\n<!-- ### Defining methods -->\n\n<!-- - A method should have **the same** arguments as the generic (plus maybe more) -->\n<!-- - The name of the method is `paste(generic,class,sep=\".\")` -->\n<!-- - Less ambiguous: use a package and declare the functions -->\n<!--     * `S3method(generic, class)` in `NAMESPACE` -->\n<!--     * `@method generic class` with `devtools` -->\n<!-- - `sloop::ftype` tells you about the type of a function -->\n<!-- - `sloop::s3_get_method` or `getAnywhere` finds methods even if they're hidden -->\n\n<!-- --- -->\n\n<!-- ### Adding methods to your class -->\n\n<!-- No *rules* on which methods, but informal standards -->\n\n<!-- - Start with `print`, `[` -->\n<!-- - `summary` for more information -->\n<!-- - `plot` or `image` if possible (`ggplot` methods take more work) -->\n<!-- - `coef`, `vcov`, maybe `logLik` and `AIC` for models -->\n<!-- - `resid` for models with residuals -->\n\n## S3: Method dispatch\n\nMethod dispatch describes the process of calling the appropriate method for the object's class.\n\nThis mostly matches `class()`, but not always for some primitive R object types. `sloop::s3_class()` shows the extra s3 dispatch classes.\n\n```\n> s3_class(1)\n[1] \"double\"  \"numeric\"\n> s3_class(matrix(1,1,1))\n[1] \"matrix\"  \"double\"  \"numeric\"\n> class(1)\n[1] \"numeric\"\n> class(matrix(1,1,1))\n[1] \"matrix\" \"array\"\n```\n\n## S3: Naming ambiguity\n\n- `t` is a generic\n- `t.test` is a generic\n- `t.test.formula` is a method for `t.test`\n- `t.data.frame` is a method for `t`\n- `list` is not generic\n- `list.files` isn't a method\n\nAvoid using `.` as a word separator in function names that aren't methods.\n\nUse `camelCase` or `snake_case` or some other consistent approach\n\n<!-- --- -->\n\n<!-- ### Defining generics -->\n\n<!-- A typical generic function includes **only** a call to `UseMethod` -->\n\n<!-- ```{r} -->\n<!-- print -->\n<!-- ``` -->\n\n<!-- --- -->\n\n<!-- ### Dispatch on another argument -->\n\n<!-- Specify which argument to use for choosing the method (default is the first) -->\n\n<!-- ``` -->\n<!-- > survey:::svymean -->\n<!-- function (x, design, na.rm = FALSE, ...) -->\n<!-- { -->\n<!--     .svycheck(design) -->\n<!--     UseMethod(\"svymean\", design) -->\n<!-- } -->\n<!-- ``` -->\n\n## S3: Inheritance\n\nThe `class` attribute of an object can have multiple elements\n\n- `UseMethod()` uses the first method that matches, or `default`\n- `NextMethod()` uses the next method that matches\n\n## S3: Polite conduct\n\n- if you define a new generic, you can define methods for new and existing classes\n- if you define a new class, you can define methods for new and existing generics\n- don't define methods for someone else's class and generic (ask them)\n- try not to define a generic with the same name as an existing one\n\n# S4\n## S4\n\nS4 requires classes and methods to be registered in R code (not just in packages)\n\n- `setClass` defines the structure of a class\n- `new` creates a new object from a class\n- `setMethod` defines a method\n\nIt's possible to ask an object what methods it supports and get a reliable response.\n\nS4 also allows multiple inheritance and multiple dispatch\n\n## S4: Bioconductor\n\n- Package system for high-throughput molecular biology\n- Large data\n- Structured data\n- Annotated data\n- New data types/structures all the time\n\nIt needs consistent infrastructure and large-scale collaboration: S4\n\n[bioconductor.org](https://bioconductor.org)\n\n## S4: Multiple dispatch\n\nChoosing a method based on the class of more than one argument\n\n- not very often useful\n- important for matrices\n- can be useful for plots\n\n## S4: Multiple inheritance\n\n`AnnDbObjBimap` is a class for storing look-up tables between different genomic identifiers (eg from different manufacturers)\n\nIt is\n\n- (by purpose) a two-way lookup object (`BiMap`)\n- (by construction) an object containing a SQLite database (`DbObj`)\n\nso it inherits generic functions from both these parents\n\n## S4: Creating a class\n\nThe structure of your S4 class is defined with `setClass()`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsetClass(\n  \"StudentGrades\",\n  slots = list(\n    name = \"character\",\n    grades = \"numeric\"\n  )\n)\n```\n:::\n\n\n## S4: Creating S4 objects\n\nS4 objects are created with the `new()` function.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstudentGrades <- function(name, grades) {\n  if (!is.character(name) || length(name) != 1) {\n    stop(\"Name must be a single string.\")\n  }\n  if (!is.numeric(grades)) {\n    stop(\"Grades must be numeric.\")\n  }\n  \n  new(\"StudentGrades\", name = name, grades = grades)\n}\n```\n:::\n\n\n## S4: Creating methods\n\nMethods are registered to S4 classes with `setGeneric()` and `setMethod()`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsetGeneric(\"averageGrade\", function(object) {\n  standardGeneric(\"averageGrade\")\n})\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"averageGrade\"\n```\n\n\n:::\n\n```{.r .cell-code}\nsetMethod(\"averageGrade\", \"StudentGrades\", function(object) {\n  mean(object@grades)\n})\n```\n:::\n\n\n## S4: Using S4 objects\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstudent <- studentGrades(\"Alice\", c(85, 90, 78))\nprint(student)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nAn object of class \"StudentGrades\"\nSlot \"name\":\n[1] \"Alice\"\n\nSlot \"grades\":\n[1] 85 90 78\n```\n\n\n:::\n\n```{.r .cell-code}\naverage <- averageGrade(student)\nprint(paste(\"Average Grade:\", average))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Average Grade: 84.3333333333333\"\n```\n\n\n:::\n:::\n\n\n## S4: Accessing S4 slots\n\nContents of an S4 object are extracted with `@`.\n\nFor example, the student's name can be obtained with:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstudent@name\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Alice\"\n```\n\n\n:::\n:::\n\n\n# S7\n\n## S7\n\nS7 = S3 + S4\n\nIt aims to maintain the simplicity of S3, while adding useful features from S4.\n\n(and unify CRAN and Bioconductor packages!)\n\nIt's not yet in R-Core, but it can be used via the `S7` package.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(S7)\n```\n:::\n\n\n## S7: Creating a class\n\nLike S4, S7 starts by defining the data structure.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstudent <- new_class(\n  name = \"student\",\n  properties = list(\n    name = class_character,\n    grades = class_double\n  )\n)\n```\n:::\n\n\n## S7: Self-validation\n\nS7 additionally supports property validation\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstudent <- new_class(\n  name = \"student\",\n  properties = list(\n    name = class_character,\n    grades = class_double\n  ),\n  validator = function(self) {\n    if (any(self@grades < 0 | self@grades > 100)) {\n      \"@grades must be between 0 and 100\"\n    }\n  }\n)\n```\n:::\n\n\n## S7: S7 classes are also constructors\n\nThe S7 class `student` is also a (pure) constructor function.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- student(name = \"Alice\", grades = c(85, 90, 78))\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n<student>\n @ name  : chr \"Alice\"\n @ grades: num [1:3] 85 90 78\n```\n\n\n:::\n:::\n\n\nThe `validator` prevents invalid grades.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstudent(name = \"Mitch\", grades = c(-10, 140))\n```\n\n::: {.cell-output .cell-output-error}\n\n```\nError: <student> object is invalid:\n- @grades must be between 0 and 100\n```\n\n\n:::\n:::\n\n\n## S7: Creating generics\n\nS7 generics are created with `new_generic()`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbest_grade <- new_generic(\"best_grade\", dispatch_args = \"x\")\n```\n:::\n\n\nHere we explicitly specify which argument(s) are used in finding the appropriate method. Double (or multiple) dispatch is supported!\n\n## S7: Creating methods\n\nS7 methods are created with `method<-`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmethod(best_grade, student) <- function(x) {\n  max(x@grades)\n}\nbest_grade(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 90\n```\n\n\n:::\n:::\n\n\n<!-- # R6 -->\n\n<!-- ## R6 -->\n\n<!-- Remember function factories from last week? -->\n\n<!-- - Create a function closure with useful variables in its environment -->\n<!-- - These variables are visible inside the function -->\n\n<!-- Now do this with -->\n\n<!-- - multiple variables in the shared environment -->\n<!-- - multiple functions inheriting this environment -->\n<!-- - allow the shared variables to be modified -->\n\n<!-- --- -->\n\n<!-- #### R6 is good for... -->\n\n<!-- - large data objects, to reduce copying -->\n<!-- - external objects that R can't just copy (database connections, files,... ) -->\n<!-- - shared state such as games -->\n\n<!-- R6 is more similar to C++/Java/Python OOP. It doesn't really support functional programming -->\n\n<!-- [R6.r-lib.org](https://r6.r-lib.org/articles/Introduction.html) -->\n",
    "supporting": [
      "slides_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": null,
    "postProcess": false
  }
}