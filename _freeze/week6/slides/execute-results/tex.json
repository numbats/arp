{
  "hash": "3c8a0b43c519f757dd0e111e21895071",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: ETC4500/ETC5450 Advanced&nbsp;R&nbsp;programming\nauthor: \"Week 4: Literate programming with Quarto\"\nformat:\n  presentation-beamer:\n    fontsize: \"14pt,t\"\n    section-titles: false\n    knitr:\n      opts_chunk:\n        dev: \"cairo_pdf\"\n    fig-width: 7.5\n    fig-height: 3.5\n    include-in-header: ../header.tex\n    colorlinks: true\n    urlcolor: MonashBlue\n    linkcolor: burntorange\n---\n\n\n\n## Outline\n\n\\vspace*{0.4cm}\n\\tableofcontents\n\n# Programming paradigms\n\n## Programming paradigms\n\n::: {.callout-note icon=false title=\"Functional programming (W5)\"}\n* Functions are created and used like any other object.\n* Output should only depend on the function's inputs.\n:::\n\n. . .\n\n::: {.callout-note icon=false title=\"Object-oriented programming (W6-W7)\"}\n* Functions are associated with object types.\n* Methods of the same 'function' produce object-specific output.\n:::\n\n## Programming paradigms\n\n::: {.callout-note icon=false title=\"Reactive programming (W8)\"}\n* Objects are expressed using code based on inputs.\n* When inputs change, the object's value updates.\n:::\n\n::: {.callout-note icon=false title=\"Literate programming (W8)\"}\n* Natural language is interspersed with code.\n* Aimed at prioritising documentation/comments.\n* Now used to create reproducible reports/documents.\n:::\n\n# Reactive programming\n\n## Regular (imperative) programming\n\nConsider how code is usually evaluated...\n\n::: {.cell}\n\n```{.r .cell-code}\na <- 1\nb <- 2\nx <- a + b\nx\n```\n:::\n\nWhat is `x`?\n\n::: {.cell}\n\n```{.r .cell-code}\na <- -1\nx\n```\n:::\n\nWhat is `x` now?\n\n## Regular (imperative) programming\n\n::: {.callout-tip title=\"Predictable programming\"}\nAll programming we've seen so far evaluates code in sequential order, line by line.\n\n\\hspace{1em}\n\nSince `x` was not re-evaluated, its value stays the same even when its inputs have changed.\n:::\n\n<!-- . . . -->\n\n<!-- *Note: this is why it's especially important to ensure code works when ran from top to bottom, since when doing a data analysis we often write and run code more freely!* -->\n\n## Reactive programming\n\nWithin a reactive programming paradigm, objects *react* to changes in their inputs and automatically update their value!\n\n. . .\n\n::: {.callout-warning title=\"Disclaimer\"}\nReactive programming is a broad and diverse paradigm, we'll focus only on the basic concepts and how they apply in shiny applications.\n:::\n\n## Reactive programming\n\nWe can implement *reactivity* with functions & environments.\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(rlang)\nreact <- function(e) new_function(alist(), expr(eval(!!enexpr(e))))\n```\n:::\n\nWe'll learn how this function works later (metaprogramming).\n\nReactive programming is also smarter about *'invalidation'*, results are **cached and reused** if the inputs aren't changed.\n\n## Reactive programming\n\nHow does reactive programming differ?\n\n::: {.cell}\n\n```{.r .cell-code}\na <- 1\nb <- 2\ny <- react(a + b)\ny()\n```\n:::\n\nWhat is `y`?\n\n::: {.cell}\n\n```{.r .cell-code}\na <- -1\ny()\n```\n:::\n\nWhat is `y` now?\n\n## Reactive programming\n\n::: {.callout-tip title=\"(Un)predictable programming?\"}\nReactive programming can be disorienting!\n\n\\hspace{1em}\n\nReactive objects *invalidate* whenever their inputs change, and so its value will be recalculated and stay up-to-date.\n:::\n\n## Reactive programming\n\n::: {.callout-caution title=\"Your turn!\"}\n<!-- Experiment with using `react()` in R. -->\n\n<!-- ```{r} -->\n<!-- library(rlang) -->\n<!-- react <- function(e) new_function(alist(), expr(eval(!!enexpr(e)))) -->\n<!-- ``` -->\n\n::: {.cell}\n\n```{.r .cell-code}\na <- 1\nb <- 2\ny <- react(a + b)\ny()\n```\n:::\n\nWhen was `a + b` evaluated?\n\n\\vspace{1em}\n\nHow does this differ from ordinary (imperative) code?\n:::\n\n## Imperative and declarative programming\n\n\\fontsize{13}{13}\\sf\n::: {.callout-note icon=false title=\"Imperative programming\"}\n* Specific commands are carried out immediately.\n* Usually direct and exact instructions.\n* e.g. read in data from this file.\n:::\n\n::: {.callout-note icon=false title=\"Declarative programming\"}\n* Specific commands are carried out when needed.\n* Expresses higher order goals / constraints.\n* e.g. make sure this dataset is up to date every time I see it.\n:::\n\n## Imperative and declarative programming\n\n::: {.callout-note icon=false title=\"Mastering Shiny: Chapter 3 (Basic Reactivity)\"}\nWith imperative code you say “Make me a sandwich”.\n\n\\hspace{1em}\n\nWith declarative code you say “Ensure there is a sandwich in the refrigerator whenever I look inside of it”.\n\n\\hspace{1em}\n\n*Imperative code is **assertive**; *\n\n*declarative code is **passive-aggressive**.*\n:::\n\n\n\n## Use cases for reactive programming\n\n\\fontsize{13}{13}\\sf\n::: {.callout-important title=\"Use-less cases\"}\nThis paradigm is rarely needed or used in R for data analysis.\n:::\n\n::: {.callout-tip title=\"Useful cases\"}\nReactive programming is useful for developing user applications (including web apps!).\n\n\\vspace{1em}\n\nIn R, the shiny package uses reactive programming for writing app interactivity.\n:::\n\n<!-- ## Invalidation -->\n\n<!-- ## Laziness -->\n\n<!-- ## Debugging -->\n\n# Shiny\n\n## A shiny app\n\nMost shiny apps are organised into several files.\n\n* `ui.R`: The specification of the user interface\n* `server.R`: The reactive code that defines app behaviour\n* `global.R`: Static global objects used across app\n* `www/`: Folder for your web data (images, css, js, etc.)\n\nSimple apps can consist of only an `app.R` script.\n\n## Hello *shiny*!\n\n::: {.callout-caution title=\"Follow along!\"}\nCreate a shiny app. Save this code as `app.R`.\n\n```r\nlibrary(shiny)\nui <- fluidPage(\n  textInput(\"name\", \"Enter your name: \"),\n  textOutput(\"greeting\")\n)\nserver <- function(input, output, session) {\n  output$greeting <- renderText({\n    sprintf(\"Hello %s\", input$name)\n  })\n}\nshinyApp(ui, server)\n```\n:::\n\n## Hello *shiny*!\n\n::: {.callout-caution title=\"Follow along!\"}\nLaunch the app by clicking **Run App**.\n\n\\vspace{1em}\n\nUse the text input field and see how the webpage changes.\n\n\\vspace{1em}\n\nLook at the server code to see how it 'reacts'.\n:::\n\n\n## Shiny reactivity\n\nReactivity in shiny comprises of:\n\n* Reactive **sources** (inputs):\n\n  UI inputs `input*()` and values `reactiveValues()`\n\n* Reactive **conductors** (intermediates):\n\n  Expressions `reactive()` and events `eventReactive()`\n\n* Reactive **endpoints** (results):\n\n  UI outputs `render*()` and side-effects `observe()`\n\n## Reactive graphs\n\n![](../diagrams/reactive/react-graph.png)\n\nThe reactivity of an app can be visualised with a graph.\n\n## Reactive graphs\n\n![](../diagrams/reactive/reactlog-components.png)\n\nThe graph shows relationships between reactive elements.\n\n## reactlog\n\n\\fontsize{12}{12}\\sf\n\nThe [reactlog package](https://rstudio.github.io/reactlog/) allows you to visualise an app's **reactive graph**.\n\nTo **enable logging** of an app's behaviour, run:\n\n::: {.cell}\n\n```{.r .cell-code}\nreactlog::reactlog_enable()\n```\n:::\n\nThen **start, use, and stop your app** to fill the log.\n\nView the log with:\n\n::: {.cell}\n\n```{.r .cell-code}\nshiny::reactlogShow()\n```\n:::\n\nOr while your Shiny app is running, press the key combination Ctrl+F3 (Mac: Cmd+F3) to see the reactive log.\n\n## Hello *reactlog*!\n\n::: {.callout-caution title=\"Follow along!\"}\nCreate a reactive log of the *hello shiny* app.\n\n\\vspace{1em}\n\nStart reactlog, then open the app and enter your name.\n\n\\vspace{1em}\n\nClose the app and view the log, see how the app reacts to changes to the input text.\n:::\n\n## Reactive expressions\n\nReactive expressions are used in the shiny server as intermediate calculations.\n\nThey are expressions wrapped with `reactive()`.\n\nFor example:\n\n::: {.cell}\n\n```{.r .cell-code}\nsimulation <- reactive(rnorm(input$n_samples))\n```\n:::\n\n. . .\n\nThe up-to-date value is obtained with `simulation()`.\n\nWhenever the input ID `n_samples` changes, the reactive expression `simulation` *invalidates*.\n\n## Reactive expressions\n\n::: {.callout-caution title=\"Follow along!\"}\nUse a reactive expression to convert the name to ALLCAPS.\n\n\\vspace{1em}\n\nLook at the reactive graph and see how it changes.\n:::\n\n## Preventing reactivity\n\nEqually important to telling shiny **how** to react to changes, is describing **when** reactions should (not) occur.\n\n\\\n\n. . .\n\nThe most useful way to prevent reactivity is with `req()`.\n\nIt is similar to `stop()`, silently ending the reactive chain.\n\n`req()` *'requires'* inputs to be 'truthy' (not FALSE or empty).\n\n<!-- This is useful for preventing code from running when no input is given, or if an invalid input is given. -->\n\n## Preventing reactivity\n\n::: {.callout-caution title=\"Follow along!\"}\nUse `req()` to prevent reactivity until text is entered.\n\n\\vspace{1em}\n\nUpdate `req()` to require at least 3 characters inputted.\n:::\n\n## Preventing reactivity\n\nOther ways reactivity might be prevented include:\n\n* Event reactivity\n\n  * `eventReactive(rnorm(input$n_samples), input$go)`\n  * `observeEvent(input$go, message(\"Go!\"))`\n\n* Rate limiting\n\n  * `throttle(reactive())`: limits update frequency\n  * `debounce(reactive())`: waits for changes to stop\n\n# Literate programming\n\n## Literate programming\n\n * Due to Donald Knuth (Stanford), 1984\n * A script or document that contains an explanation of the program logic in a natural language (e.g. English), interspersed with snippets of source code, which can be compiled and rerun.\n * Generates two representations\\newline from a source file: formatted\\newline documentation and \"tangled\" code.\n\n\\placefig{10.5}{4.6}{width = 6cm}{WEB.png}\n\n## Literate programming\n\n* As a programming approach, it never quite caught on.\n* But it has become the standard approach for reproducible documents.\n\n## Literate programming examples\n\n* WEB (combining Pascal and TeX)\n* roxygen2 comments\n  * technically documentation generation rather than literate programming\n  * documentation embedded in code, rather than code embedded in documentation\n* Sweave documents\n* Jupyter notebooks\n* Rmarkdown documents\n* Quarto documents\n\n# roxygen2\n## roxygen2\n\n* roxygen2 documentation are just comments to R.\n* roxygen2::roxygenize():\n  * generates documentation from these comments in the form of Rd files\n  * adds relevant lines to the NAMESPACE file.\n* roxygen2::roxygenize() is called by devtools::document().\n* Advantage: keeps documentation with the code. More readable, less chance for errors.\n\n# Rmarkdown\n\n## Markdown syntax\n\\fontsize{14}{16}\\sf\nMarkdown: a \"markup\" language for formatting text.\n\n* Headings:\n\n    `# Heading 1`\\newline\n    `## Heading 2`\n\n* **Bold**: `**bold**`.\n* *Italic*: `*italic*`.\n* Blockquotes:\n\n    `> blockquote`.\n\n## Markdown and Rmarkdown\n\n* Markdown (markup language):\n  * Extension either `.md` or `.markdown`.\n  * Used in many places on the web, in note-taking apps, etc.\n\n* Rmarkdown (markup language):\n  * an extension of markdown that allows for embedded R code chunks.\n  * Extension `.Rmd`.\n\n* Rmarkdown (package):\n  * an R package that allows for the conversion of `.Rmd` files to other formats.\n\n## Rmarkdown files\n\n* Structure:\n  1. YAML header\n  2. Markdown content\n  3. R code chunks surrounded by `` ```{r} `` and `` ``` ``\n  4. Inline R surrounded by `` `r `` and `` ` ``\n\n* Rmarkdown documents can be compiled to HTML, PDF, Word, and other formats\n* Compile with `rmarkdown::render(\"file.Rmd\")`\n\n## Rmarkdown, knitr and pandoc\n\n* `rmarkdown::render()`\n  * Uses `knitr` to run all code chunks, and \"knit\" the results into a markdown file (replacing R chunks with output).\n  * Uses `pandoc` to convert the markdown file to the desired output format.\n  * If PDF output is desired, LaTeX then converts the tex file (from pandoc output) to pdf.\n\n\\centerline{\\includegraphics[width = 10cm]{rmd.png}}\n\n## knitr functions\n\n* `knitr::knit()`: knits a single Rmd file --- runs all code chunks and replaces them with output in a markdown file.\n* `knitr::purl()`: extracts all R code from an Rmd file and saves it to a new file.\n* `knitr::spin()`: knits a specially formatted R script file into an Rmd file.\n\n## Rmarkdown packages\n\n  * rmarkdown (to html, pdf, docx, odt, rtf, md, etc.)\n  * bookdown (to html, pdf, epub)\n  * blogdown (to html) -- uses hugo rather than pandoc\n  * xaringan (to html) -- uses remark.js rather than pandoc\n  * beamer (to pdf)\n  * rticles (to pdf)\n  * tufte (to html, pdf)\n  * vitae (to pdf)\n  * distill (to html)\n  * flexdashboard (to html)\n\n## Some chunk options\n\\fontsize{14}{16}\\sf\n\n* `eval`: whether to evaluate the code chunk\n* `echo`: whether to display the code chunk\n* `include`: whether to include the code chunk in the output\n* `results = 'hide'` hides printed output.\n* `results = 'asis'` includes the output as is.\n* `message`: whether to display messages\n* `warning`: whether to display warnings\n* `error = TRUE`: continue even if code returns an error.\n* `fig.cap`: caption for the figure\n* `fig.width`, `fig.height`: width and height of the figure\n* `cache`: whether to cache the code chunk\n\n## Global chunk options\n\n\n````{.default}\n```{r setup, include=FALSE}\nknitr::opts_chunk$set(\n  comment = \"#>\",\n  collapse = TRUE,\n  echo = FALSE,\n  message = FALSE,\n  warning = FALSE\n)\n```\n````\n\n* The chunk named `setup` will be run before any other chunks.\n\n## Debugging\n\n* The Rmarkdown document is compiled in a different environment from your R console.\n* If you get an error, try running all chunks (Ctrl+Alt+R).\n* If you can't reproduce the error, check the working directory (add `getwd()` in a chunk).\n* Try setting `error = TRUE` on problem chunk to help you diagnose what happens. (But change it back!)\n* Look at the intermediate files (`.md` or `.tex`) to see what is happening.\n\n## Caching\n\n\n\n````{.default}\n```{r setup, include=FALSE}\nknitr::opts_chunk$set(cache = TRUE)\n```\n````\n\nor by chunk:\n\n\n````{.default}\n```{r, cache = TRUE}\n```\n````\n\n\n## Caching\n\n* When evaluating code chunks, knitr will save the results of chunks with caching to files to be reloaded in subsequent runs.\n* Caching is useful when a chunk takes a long time to run.\n* It will re-run if the code in the chunk changes in any way (even comments or spacing).\n* Beware of inherited objects from earlier chunks. A chunk will not re-run if inherited objects change without explicit dependencies.\n* Beware of dependence on external files.\n\n## Caching\n\n\n````{.default}\n```{r chunk1, cache = TRUE}\nx <- 1\n```\n\n```{r chunk2, cache = TRUE, dependson = \"chunk1\"}\ny <- x*3\n```\n````\n\n\\pause\n\n\n````{.default}\n```{r chunk1, cache = TRUE}\nx <- 1\n```\n\n```{r chunk2, cache = TRUE, cache.extra = x}\ny <- x*3\n```\n````\n\n\n## Caching\n\nCache will be rebuilt if:\n\n* Chunk options change except `include`\n* Any change in the code, even a space or comment\n* An explicit dependency changes\n\nDo not cache if:\n\n * setting R options like `options('width')`\n * setting knitr options like `opts_chunk$set()`\n * loading packages via `library()` if those packages are used by uncached chunks\n\n## Caching with random numbers\n\n\n````{.default}\n```{r setup, include=FALSE}\nknitr::opts_chunk$set(cache.extra = knitr::rand_seed)\n```\n````\n\n* `rand_seed` is an unevaluated expression.\n* Each chunk will check if `.Random.seed` has been changed since the last run.\n* If it has, the chunk will be re-run.\n\n## Some caching options\n\\fontsize{14}{15}\\sf\n\n* `cache.comments` If `FALSE`, changing comments does not invalidate the cache.\n* `cache.rebuild` If `TRUE`, the cache will be rebuilt even if the code has not changed. e.g.,\\newline `cache.rebuild = !file.exists(\"some-file\")`\n* `dependson` A character vector of labels of chunks that this chunk depends on.\n* `my_new_option` A new option that you can use in your code to invalidate the cache. e.g., `my_new_option = c(x,y)`\n* `autodep` If `TRUE`, the dependencies are automatically determined. (May not be reliable.)\n\n## Caching\n\nBuild automatic dependencies among chunks\n\n\n````{.default}\n```{r setup, include=FALSE}\nknitr::opts_chunk$set(cache=TRUE, autodep = TRUE)\n```\n````\n\nMake later chunks depend on previous chunks\n\n\n````{.default}\n```{r setup, include=FALSE}\ndep_prev() # Don't use with `autodep = TRUE`\n```\n````\n\n## Child documents\n\n\n````{.default}\n```{r, child=c('one.Rmd', 'two.Rmd')}\n```\n````\n\n\\pause\\alert{Conditional inclusion}\n\n\n````{.default}\n```{r, child = if(condition) 'file1.Rmd' else 'file2.Rmd'}\n```\n````\n\n\\pause\\alert{R Script files}\n\n\n\n````{.default}\n```{r, file = c(\"Rscript1.R\", \"Rscript2.R\")}\n```\n````\n\n* Better than `source(\"Rscript1.R\")` because output of script included and dependencies tracked.\n\n## Other language engines\n\n\n````{.default}\n```{python}\nprint(\"Hello Python!\")\n```\n````\n\n\n````{.default}\n```{stata}\nsysuse auto\nsummarize\n```\n````\n\n* Python and Stata need to be installed with executables on `PATH`\n\n\n## Other language engines\n\\fontsize{12}{12}\\sf\n\n::: {.cell}\n\n```{.r .cell-code}\nnames(knitr::knit_engines$get())\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] \"awk\"       \"bash\"      \"coffee\"    \"gawk\"      \"groovy\"   \n [6] \"haskell\"   \"lein\"      \"mysql\"     \"node\"      \"octave\"   \n[11] \"perl\"      \"php\"       \"psql\"      \"Rscript\"   \"ruby\"     \n[16] \"sas\"       \"scala\"     \"sed\"       \"sh\"        \"stata\"    \n[21] \"zsh\"       \"asis\"      \"asy\"       \"block\"     \"block2\"   \n[26] \"bslib\"     \"c\"         \"cat\"       \"cc\"        \"comment\"  \n[31] \"css\"       \"ditaa\"     \"dot\"       \"embed\"     \"eviews\"   \n[36] \"exec\"      \"fortran\"   \"fortran95\" \"go\"        \"highlight\"\n[41] \"js\"        \"julia\"     \"python\"    \"R\"         \"Rcpp\"     \n[46] \"sass\"      \"scss\"      \"sql\"       \"stan\"      \"targets\"  \n[51] \"tikz\"      \"verbatim\"  \"ojs\"       \"mermaid\"   \"glue\"     \n[56] \"glue_sql\"  \"gluesql\"  \n```\n\n\n:::\n:::\n\n\n# Quarto\n\n## Quarto\n\\fontsize{14}{16}\\sf\n\n* Generalization of Rmarkdown (not dependent on R)\n* Supports R, Python, Javascript and Julia chunks by using either `knitr`, `jupyter` or `ObservableJS` engines.\n* More consistent yaml header and chunk options.\n* Many more output formats, and many more options for customizing format.\n* Heavier reliance on pandoc Lua filters\n* Uses pandoc templates for extensions\n\n\\centerline{\\includegraphics[width = 10cm]{images/qmd.png}}\n\n## Choose your engine\n\nSpecify the engine in the yaml header:\n\n\n```{.default}\n---\nengine: knitr\n---\n```\n\n\n```{.default}\n---\nengine: jupyter\njupyter: python3\n---\n```\n\n\n**Default:** If any `{r}` blocks found, use `knitr` engine; otherwise use `jupyter` (with kernel determined by first block).\n\n\n## Execute options\n\n*   `execute` option in yaml header can be used instead of a `setup` chunk:\n\n    \n    ```{.default}\n    execute:\n      cache: true\n      echo: false\n      warning: false\n    ```\n\n* `setup` chunk still allowed.\n\n## Chunk options\n\nRmarkdown syntax recognized for R chunks.\n\nMore consistent chunk options use the hash-pipe `#|`\n\n\n````{.default}\n```{r}\n#| label: fig-chunklabel\n#| fig-caption: My figure\n#| fig-width: 6\n#| fig-height: 4\nmtcars |>\n  ggplot(aes(x = mpg, y = wt)) +\n  geom_point()\n```\n````\n\nReference the figure using `@fig-chunklabel`.\n\n## Chunk options\n\n* Quarto consistently uses hyphenated options (`fig-width` rather than `fig.width`)\n* The Rmarkdown `knitr` options are recognized for backwards compatibility.\n* Options that are R expressions need to be prefaced by `!expr`\n\n  \n  ````{.default}\n  ```{r}\n  #| fig-cap: !expr paste(\"My figure\", 1+1)\n  ```\n  ````\n\n## Extensions and templates\n\\fontsize{13}{17}\\sf\n\n* Quarto extensions modify and extend functionality.\n* They are stored locally, in the `_extensions` folder alongside the qmd document.\n* See <https://quarto.org/docs/extensions/> for a list.\n* Templates are extensions used to define new output formats.\n* Journal templates at\\newline <https://quarto.org/docs/extensions/listing-journals.html>\n* Monash templates at\\newline <https://robjhyndman.com/hyndsight/quarto_templates.html>\n\n## quarto on the command line\n\\fontsize{14}{14.5}\\sf\\vspace*{-0.4cm}\n\n* `quarto render` to render a quarto or Rmarkdown document.\n* `quarto preview` to preview a quarto or Rmarkdown document.\n* `quarto add <gh-org>/<gh-repo>` to add an extension from a github repository.\n* `quarto update <gh-org>/<gh-repo>` to update an extension\n* `quarto remove <gh-org>/<gh-repo>` to remove an extension\n* `quarto list extensions installed`\n* `quarto use template <gh-org>/<gh-repo>` to use existing repo as starter template.\n\n## Add a custom format\n\nFrom the CLI:\\qquad  `quarto add numbats/monash-quarto-memo`\\pause\n\nNew folder/files added\n\n\n```{.default}\n├── _extensions\n│   └── numbats\n│       └── memo\n│           └── ...\n```\n\n\\pause\n\nUpdate YAML\n\n\n```{.default}\n---\ntitle: \"My new file using the `memo-pdf` format\"\nformat: memo-pdf\n---\n```\n\n## Exercise\n\n* Set up a new project.\n* Create a quarto document using an html format.\n* Add a code chunk to generate a figure with a caption.\n* Reference the figure in the text using `@fig-chunklabel`.\n* Add the monash memo extension and generate a pdf output.\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": null,
    "postProcess": false
  }
}