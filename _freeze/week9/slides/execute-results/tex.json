{
  "hash": "93a47f0f1f0cf6b0762dd086eacdd573",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: ETC4500/ETC5450 Advanced&nbsp;R&nbsp;programming\nauthor: \"Week 9: Object-oriented programming (vctrs)\"\nformat:\n  presentation-beamer:\n    fontsize: \"14pt,t\"\n    section-titles: false\n    knitr:\n      opts_chunk:\n        dev: \"cairo_pdf\"\n    fig-width: 7.5\n    fig-height: 3.5\n    include-in-header: ../header.tex\n    keep-tex: false\n---\n\n\n\n\n\n# Programming paradigms\n\n## Programming paradigms\n\n::: {.callout-note icon=false title=\"Functional programming (W5)\"}\n* Functions are created and used like any other object.\n* Output should only depend on the function's inputs.\n:::\n\n. . .\n\n::: {.callout-note icon=false title=\"Literate programming (W6)\"}\n* Natural language is interspersed with code.\n* Aimed at prioritising documentation/comments.\n* Now used to create reproducible reports/documents.\n:::\n\n## Programming paradigms\n\n::: {.callout-note icon=false title=\"Reactive programming (W7)\"}\n* Objects are expressed using code based on inputs.\n* When inputs change, the object's value updates.\n:::\n\n. . .\n\n::: {.callout-note icon=false title=\"Object-oriented programming (W8-W9)\"}\n* Functions are associated with object types.\n* Methods of the same 'function' produce object-specific output.\n:::\n\n\n# S3 Recap\n\n## Comparing S3 and vctrs\n\n::: {.callout-note icon=false title=\"S3\"}\n* The OO system used by most of CRAN.\n* Very simple (and 'limited') compared to other systems.\n:::\n\n. . .\n\n::: {.callout-note icon=false title=\"vctrs\"}\n* Builds upon S3 to make creating vectors easier.\n* Good practices inherited by default.\n:::\n\n\n## S3 Recap: Objects and methods\n\nUnlike most OO systems where methods belong to **objects/data**, S3 methods *belong* to 'generic' **functions**.\n\nRecall that functions in R are objects like any other.\n\n. . .\n\n\n::: {.callout-tip title=\"Self awareness\"}\nIn S3, there is no concept of 'self' since the relevant objects are available as function arguments.\n\nHowever S3 is self-aware of registered methods, allowing `NextMethod()` to call the S3 method of the inherited class.\n:::\n\n## S3 Recap: S3 dispatch\n\nTo use S3, we call the generic function (e.g. `plot()`).\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplot\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nfunction (x, y, ...) \nUseMethod(\"plot\")\n<bytecode: 0x5b161ba2a3c8>\n<environment: namespace:base>\n```\n\n\n:::\n:::\n\n\n## S3 Recap: S3 dispatch\n\nThis function looks at the inputs and dispatches (uses) the appropriate method for the input variable class/type.\n\n\\fontsize{10}{10}\\sf\n\n::: {.cell}\n\n```{.r .cell-code}\nstats:::plot.density\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nfunction (x, main = NULL, xlab = NULL, ylab = \"Density\", type = \"l\", \n    zero.line = TRUE, ...) \n{\n    if (is.null(xlab)) \n        xlab <- paste(\"N =\", x$n, \"  Bandwidth =\", formatC(x$bw))\n    if (is.null(main)) \n        main <- sub(\"[.]default\", \"\", deparse(x$call))\n    plot.default(x, main = main, xlab = xlab, ylab = ylab, type = type, \n        ...)\n    if (zero.line) \n        abline(h = 0, lwd = 0.25, col = \"gray\")\n    invisible(NULL)\n}\n<bytecode: 0x5b1620655c80>\n<environment: namespace:stats>\n```\n\n\n:::\n:::\n\n\n## S3 Recap: S3 dispatch\n\nIf there isn't a registered method for the object, the default method for the generic will be used.\n\n\\fontsize{10}{10}\\sf\n\n::: {.cell}\n\n```{.r .cell-code}\ngraphics:::plot.default\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nfunction (x, y = NULL, type = \"p\", xlim = NULL, ylim = NULL, \n    log = \"\", main = NULL, sub = NULL, xlab = NULL, ylab = NULL, \n    ann = par(\"ann\"), axes = TRUE, frame.plot = axes, panel.first = NULL, \n    panel.last = NULL, asp = NA, xgap.axis = NA, ygap.axis = NA, \n    ...) \n{\n    localAxis <- function(..., col, bg, pch, cex, lty, lwd) Axis(...)\n    localBox <- function(..., col, bg, pch, cex, lty, lwd) box(...)\n    localWindow <- function(..., col, bg, pch, cex, lty, lwd) plot.window(...)\n    localTitle <- function(..., col, bg, pch, cex, lty, lwd) title(...)\n    xlabel <- if (!missing(x)) \n        deparse1(substitute(x))\n    ylabel <- if (!missing(y)) \n        deparse1(substitute(y))\n    xy <- xy.coords(x, y, xlabel, ylabel, log)\n    if (is.null(xlab)) \n        xlab <- xy$xlab\n    if (is.null(ylab)) \n        ylab <- xy$ylab\n    if (is.null(xlim)) \n        xlim <- range(xy$x[is.finite(xy$x)])\n    if (is.null(ylim)) \n        ylim <- range(xy$y[is.finite(xy$y)])\n    dev.hold()\n    on.exit(dev.flush())\n    plot.new()\n    localWindow(xlim, ylim, log, asp, ...)\n    panel.first\n    plot.xy(xy, type, ...)\n    panel.last\n    if (axes) {\n        localAxis(if (is.null(y)) \n            xy$x\n        else x, side = 1, gap.axis = xgap.axis, ...)\n        localAxis(if (is.null(y)) \n            x\n        else y, side = 2, gap.axis = ygap.axis, ...)\n    }\n    if (frame.plot) \n        localBox(...)\n    if (ann) \n        localTitle(main = main, sub = sub, xlab = xlab, ylab = ylab, \n            ...)\n    invisible()\n}\n<bytecode: 0x5b161e6a4c10>\n<environment: namespace:graphics>\n```\n\n\n:::\n:::\n\n\n## S3 Recap: Generic functions\n\nS3 generics are work like any ordinary function, but they include `UseMethod()` which calls the appropriate method.\n\n::: {.callout-caution title=\"Last week...\"}\nLast week we wrote a generic function `reverse()`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nreverse <- function(x, ...) {\n  UseMethod(\"\")\n}\n```\n:::\n\n\n:::\n\n## S3 Recap: S3 methods\n\nAn S3 method is an ordinary function with some constraints:\n\n* The function's name is of the form `<generic>.<class>`,\n* The function's arguments match the generic's arguments,\n* The function is registered as an S3 method (for packages).\n\nThis looks like:\n\n```r\n#' Documentation for the method\n#' @method <generic> <class>\n<generic>.<class> <- function(<generic args>, <method args>, ...) {\n  # The code for the method\n}\n```\n\n## S3 Recap: S3 methods\n\n::: {.callout-caution title=\"Last week...\"}\nWe wrote methods for reversing `character`, `integer`, and `double` objects.\n\nSome solutions were very creative (and I promised honey!)\n\n\n::: {.cell}\n\n```{.r .cell-code}\nreverse.integer <- function(x) {\n  ndigits <- floor(log10(x))\n  digits <- seq(floor(log10(x)))\n  x*(10^ndigits) - (99*sum(floor(x*10^-digits)*(10^(ndigits-digits))))\n}\n```\n:::\n\n:::\n\n## S3 Recap: default methods\n\nDefault methods are called when there is no specific method for the object (no class, or no matching class).\n\nSome examples include:\n\n- `mean.default`\n- `summary.default`\n- `head.default`\n\n\n## S3 Recap: S3 objects\n\nTo create an S3 object, we add a class to an object.\n\nThis is usually done with `structure()`, for example:\n\n\\fontsize{10}{10}\\sf\n\n::: {.cell}\n\n```{.r .cell-code}\ne <- structure(list(numerator = 2721, denominator = 1001), class = \"fraction\")\ne\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$numerator\n[1] 2721\n\n$denominator\n[1] 1001\n\nattr(,\"class\")\n[1] \"fraction\"\n```\n\n\n:::\n:::\n\n\n\n## S3 Recap: Constructor functions\n\nThese functions return classed S3 objects. They should handle input validation and be user-friendly.\n\nConstructor functions typically come in two forms:\n\n- complex: `tibble`, `lm`, `acf`, `svydesign`\n- pure: `new_factor`, `new_difftime`\n\nPure constructor functions simply validate inputs and produce the classed object, while complex constructor functions involve calculations.\n\n## S3 Recap: Constructor functions\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfraction <- function(numerator, denominator) {\n  # Validate inputs\n  stopifnot(is.numeric(numerator))\n  stopifnot(is.numeric(denominator))\n  if (any(denominator == 0)) stop(\"I won't let you divide by 0.\")\n\n  # Create the data structure (list)\n  x <- list(numerator = numerator, denominator = denominator)\n\n  # Return a classed S3 object\n  structure(x, class = \"fraction\")\n}\n```\n:::\n\n\n# vctrs\n\n## Creating your own S3 vectors (with vctrs)\n\nThe *vctrs* package is helpful for creating custom vectors.\n\nIt is built upon S3, so the same approach for creating S3 generics and S3 methods also applies to vctrs.\n\n::: {.callout-tip title=\"S3 or vctrs?\"}\n* Regular S3 is useful for creating singular objects\n* vctrs is useful for creating vectorised objects\n:::\n\n\n## Creating your own S3 vectors (with vctrs)\n\n::: {.callout-tip title=\"Why vctrs?\"}\n*vctrs* simplifies the complicated parts in creating vectors\n\n* easy subsetting\n* nice printing\n* predictable recycling\n* casting / coercion\n* tidyverse compatibility\n:::\n\n## Examples of vctrs packages\n\nLots of vctrs including:\n\n* IP addresses\n* Spatial geometries\n* Time\n* uncertainty\n\n<https://github.com/krlmlr/awesome-vctrs>\n\n## Some packages I've made that use vctrs\n\n* [distributional](https://github.com/mitchelloharawild/distributional/)\n\n  Distributions of various shapes in vectors\n* [mixtime](https://github.com/mitchelloharawild/mixtime)\n\n  Time points/intervals of various granularities in vectors\n* [graphvec](https://github.com/mitchelloharawild/graphvec/)\n\n  Graph factors, storing graph edges between levels.\n* [fabletools](https://github.com/tidyverts/fabletools/)\n\n  Custom data frames 'mable', 'fable', and 'dable'.\n\n## Creating a new vctr\n\nThe basic way to produce a vctr is with `vctrs::new_vctr()`.\n\nJust like `structure()`, you provide an object and its new class.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nattendance <- vctrs::new_vctr(c(80, 70, 75, 50), class = \"percent\")\nattendance\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n<percent[4]>\n[1] 80 70 75 50\n```\n\n\n:::\n:::\n\n\n## Creating a new vctr\n\nAs with S3, functions provide ways for users to create vectors.\n\n\n::: {.cell}\n\n```{.r .cell-code}\npercent <- function(x) {\n  vctrs::new_vctr(x, class = \"percent\")\n}\nattendance <- percent(c(80, 70, 75, 50))\nattendance\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n<percent[4]>\n[1] 80 70 75 50\n```\n\n\n:::\n:::\n\n\n## Creating a new vctr\n\nDon't forget to check the inputs, vctrs provides helpful functions to make this easier and provide informative errors.\n\n\n::: {.cell}\n\n```{.r .cell-code}\npercent <- function(x) {\n  vctrs::vec_assert(x, numeric())\n  vctrs::new_vctr(x, class = \"percent\")\n}\npercent(\"80%\")\n```\n\n::: {.cell-output .cell-output-error}\n\n```\nError in `percent()`:\n! `x` must be a vector with type <double>.\nInstead, it has type <character>.\n```\n\n\n:::\n:::\n\n\n## Creating a new vctr\n\nIt's useful to provide default arguments in this function which creates a length 0 vector (similar to how empty vectors are created with `numeric()` and `character()`).\n\n\n::: {.cell}\n\n```{.r .cell-code}\npercent <- function(x = numeric()) {\n  vctrs::vec_assert(x, numeric())\n  vctrs::new_vctr(x, class = \"percent\")\n}\npercent()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n<percent[0]>\n```\n\n\n:::\n:::\n\n\n## Creating a new vctr\n\nWhile vctrs provides a nice `print` method, we need to specify how our vector should be formatted.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nformat.percent <- function(x, ...) {\n  paste0(vctrs::vec_data(x), \"%\")\n}\nattendance\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n<percent[4]>\n[1] 80% 70% 75% 50%\n```\n\n\n:::\n:::\n\n\n\n## The rcrd type\n\nA special type of vctr is a record (rcrd).\n\nA record is a list containing equal length vectors, and its size is the length its vectors rather than its list.\n\n::: {.callout-tip title=\"Record indexing\"}\nUsually in R, indexing happens across the list. With the record type, indexing happens within the list's vectors.\n:::\n\n## The rcrd type\n\n::: {.callout-tip title=\"Length of a data frame\"}\nUsually the length of data refers to the number of rows, but in R it is the number of columns since it is a list.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlength(mtcars)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 11\n```\n\n\n:::\n:::\n\n\nIn vctrs, data is a record so we get the number of rows.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvctrs::vec_size(mtcars)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 32\n```\n\n\n:::\n:::\n\n\n:::\n\n## Creating a new rcrd\n\nA record is created with the `vctrs::new_rcrd()` function.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwallet <- vctrs::new_rcrd(\n  list(amt = c(10, 38), unit = c(\"AU$\", \"¥\")), class = \"currency\"\n)\nformat.currency <- function(x, ...) {\n  paste0(vctrs::field(x, \"unit\"), vctrs::field(x, \"amt\"))\n}\nwallet\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n<currency[2]>\n[1] AU$10 ¥38  \n```\n\n\n:::\n:::\n\n\n## Creating a new rcrd\n\n::: {.callout-caution title=\"Your turn!\"}\nRewrite the `fraction()` function to use the rcrd data type.\n\n\\vspace{1em}\n\nYou will also need to update the methods:\n\n* Obtain the numerator and denominator with `field()`.\n* Replace the `print` method with a `format` method.\n* Remove the `print.fraction` method with `rm()`.\n:::\n\n## The list_of type\n\n`list_of()` vectors require list elements to be the same type.\n\nIt can be created with `list_of()`, or more easily converted to with `as_list_of()`. It behaves identically to `new_vctr()`.\n\n\\fontsize{10}{10}\\sf\n\n::: {.cell}\n\n```{.r .cell-code}\nvctrs::as_list_of(list(80, 70, 75, 50), .ptype = numeric())\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n<list_of<double>[4]>\n[[1]]\n[1] 80\n\n[[2]]\n[1] 70\n\n[[3]]\n[1] 75\n\n[[4]]\n[1] 50\n```\n\n\n:::\n:::\n\n\n## Prototypes\n\nNotice the `.ptype` when we used `as_list_of()`?\n\n`ptype` is shorthand for prototype, which is a size-0 vector.\n\n::: {.callout-tip title=\"Prototype attributes!\"}\nPrototypes contains all relevant attributes of the object, such as class, dimension, and levels of factors.\n:::\n\n\n## Prototypes\n\nObtain prototypes of a vector with `vctrs::vec_ptype()`.\n\n\\fontsize{10}{10}\\sf\n\n::: {.cell}\n\n```{.r .cell-code}\nvctrs::vec_ptype(1:10)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\ninteger(0)\n```\n\n\n:::\n\n```{.r .cell-code}\nvctrs::vec_ptype(rnorm(10))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nnumeric(0)\n```\n\n\n:::\n\n```{.r .cell-code}\nvctrs::vec_ptype(factor(letters))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nfactor()\nLevels: a b c d e f g h i j k l m n o p q r s t u v w x y z\n```\n\n\n:::\n\n```{.r .cell-code}\nvctrs::vec_ptype(attendance)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n<percent[0]>\n```\n\n\n:::\n:::\n\n\n## vctr, rcrd, or list_of?\n\n::: {.callout-caution title=\"Your turn!\"}\nWhat's better? The `vctr` type or `list_of`?\n:::\n\n. . .\n\nIt depends! If your vector is based on...\n\n* a single atomic vector (like `percent`) then `vctr`,\n* two or more atomic vectors (like `fraction`), then `rcrd`,\n* complicated objects (like `lm`), then `list_of`.\n\n## That's it! You have created a new vector for R!\n\n::: {.callout-note title=\"Time to celebrate with a break!\"}\nAsk questions, try using your new vector in various ways.\n:::\n\n## Methods for vctrs\n\nWhile our new vectors looks pretty and fits right in with our tidy tibbles, it isn't very useful yet.\n\n::: {.callout-tip title=\"Adding features\"}\nSince vctrs is built upon S3, the same approach for creating generic functions and methods applies to vctrs.\n:::\n\n. . .\n\nHowever there are also some important **vector specific methods** which should be written to improve usability.\n\n## (Proto)typing\n\nWe saw earlier how R coerces vectors of different types.\n\n\\fontsize{10}{10}\\sf\n\n::: {.cell}\n\n```{.r .cell-code}\nc(\"desserts\", 10)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"desserts\" \"10\"      \n```\n\n\n:::\n\n```{.r .cell-code}\nc(pi, 0L)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 3.14 0.00\n```\n\n\n:::\n\n```{.r .cell-code}\nc(-1, TRUE, FALSE)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] -1  1  0\n```\n\n\n:::\n\n```{.r .cell-code}\nc(1, Sys.Date())\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]     1 20230\n```\n\n\n:::\n:::\n\n\n## (Proto)typing\n\nWhen combining or comparing vectors of different types, R will (usually) *coerce* to the 'richest' type.\n\n![](../diagrams/vctrs/coerce.png)\n\n## (Proto)typing\n\nvctrs doesn't make any assumptions about how to coerce your vector, and instead raises an error.\n\n\\fontsize{10}{10}\\sf\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(vctrs)\nvec_c(attendance, 0.8)\n```\n\n::: {.cell-output .cell-output-error}\n\n```\nError in `vec_c()`:\n! Can't combine `..1` <percent> and `..2` <double>.\n```\n\n\n:::\n:::\n\n\n## (Proto)typing\n\nWe can specify what the common ('richest') type is by writing `vctrs::vec_ptype2()` methods.\n\n\\fontsize{10}{10}\\sf\n\n::: {.cell}\n\n```{.r .cell-code}\n#' @export\nvec_ptype2.percent.double <- function(x, y, ...) {\n  percent() # Prototype since this produces size-0\n}\nvctrs::vec_ptype2(attendance, 0.8)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n<percent[0]>\n```\n\n\n:::\n\n```{.r .cell-code}\nvctrs::vec_ptype2(0.8, attendance)\n```\n\n::: {.cell-output .cell-output-error}\n\n```\nError:\n! Can't combine `0.8` <double> and `attendance` <percent>.\n```\n\n\n:::\n:::\n\n\n## (Proto)typing\n\nCommon typing uses *double-dispatch*.\n\nWe need to define the common type in both directions.\n\n\\fontsize{10}{10}\\sf\n\n::: {.cell}\n\n```{.r .cell-code}\n#' @export\nvec_ptype2.double.percent <- function(x, y, ...) {\n  percent() # Prototype since this produces size-0\n}\nvctrs::vec_ptype2(attendance, 0.8)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n<percent[0]>\n```\n\n\n:::\n\n```{.r .cell-code}\nvctrs::vec_ptype2(0.8, attendance)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n<percent[0]>\n```\n\n\n:::\n:::\n\n\n## (Proto)typing\n\n::: {.callout-caution title=\"Your turn!\"}\nWrite methods that define the common (proto)type between `fraction` and `double` as `fraction` -> `double`.\n:::\n\n## Double dispatch\n\nUnfortunately `c()` from base R can't (yet) be changed to support double-dispatch with S3. Usually this isn't a problem,\n\n\n::: {.cell}\n\n```{.r .cell-code}\nc(attendance, attendance)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n<percent[8]>\n[1] 80% 70% 75% 50% 80% 70% 75% 50%\n```\n\n\n:::\n\n```{.r .cell-code}\nc(attendance, 0.8)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n<percent[5]>\n[1] 80%  70%  75%  50%  0.8%\n```\n\n\n:::\n:::\n\n\n## Double dispatch\n\nbut if your class isn't used in the first argument...\n\n\n::: {.cell}\n\n```{.r .cell-code}\nc(0.8, attendance)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  0.8 80.0 70.0 75.0 50.0\n```\n\n\n:::\n:::\n\n\n... your common (proto)type will be ignored!\n\n## Double dispatch\n\nvctrs uses double dispatch when needed, and using `vctrs::vec_c()` fixes many coercion problems in R.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvctrs::vec_c(0.8, attendance)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n<percent[5]>\n[1] 0.8% 80%  70%  75%  50% \n```\n\n\n:::\n\n```{.r .cell-code}\nvctrs::vec_c(1, Sys.Date())\n```\n\n::: {.cell-output .cell-output-error}\n\n```\nError in `vctrs::vec_c()`:\n! Can't combine `..1` <double> and `..2` <date>.\n```\n\n\n:::\n:::\n\n\n## Double dispatch\n\n::: {.callout-note title=\"Double dispatch inheritence\"}\nDouble dispatch in vctrs doesn't work with inheritance and so:\n\n* `NextMethod()` can't be used\n* Default methods aren't inherited/used.\n:::\n\n## Casting and coercion\n\n::: {.callout-important title=\"Converting percentages\"}\nNotice earlier how combining percentages with numbers gave the incorrect result?\n\nThis is because we haven't written a method for converting numbers into percentages.\n:::\n\n<!-- While we've established what the common (proto)type is with `vec_ptype2()`,  -->\nThe `vctrs::vec_cast()` generic is used to convert/coerce ('cast') one type into another. Time to write more methods!\n\n## Casting and coercion\n\n`vctrs::vec_cast()` also uses double dispatch.\n\n\\fontsize{10}{10}\\sf\n\n::: {.cell}\n\n```{.r .cell-code}\nvec_cast.double.percent <- function(x, to, ...) {\n  vec_data(x)/100\n}\nvec_cast.percent.double <- function(x, to, ...) {\n  percent(x*100)\n}\n\nvec_cast(0.8, percent())\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n<percent[1]>\n[1] 80%\n```\n\n\n:::\n\n```{.r .cell-code}\nvec_cast(percent(80), double())\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.8\n```\n\n\n:::\n:::\n\n\n## Casting and coercion\n\nWith both `vec_ptype2()` and `vec_cast()` methods for percentages and doubles it is now possible to combine them.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvctrs::vec_c(0.8, attendance)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n<percent[5]>\n[1] 80% 80% 70% 75% 50%\n```\n\n\n:::\n:::\n\n\nWe can also use coercion to easily perform comparisons.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nattendance > 0.7\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  TRUE FALSE  TRUE FALSE\n```\n\n\n:::\n:::\n\n\n## Casting and coercion\n\n::: {.callout-caution title=\"Your turn!\"}\nWrite a method for casting from a `fraction` to a `double`.\n\nDoes this work with `as.numeric()`?\n:::\n\n## Math and arithmetic\n\nMethods also need to be written for math and arithmetic.\n\n`vec_math()` implements mathematical functions like\n\n\\fontsize{10}{10}\\sf\n\n::: {.cell}\n\n```{.r .cell-code}\nmean(attendance)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n<percent[1]>\n[1] 68.75%\n```\n\n\n:::\n:::\n\n\n\\fontsize{14}{16}\\sf\n`vec_arith()` implements arithmetic operations like\n\n\\fontsize{10}{10}\\sf\n\n::: {.cell}\n\n```{.r .cell-code}\nattendance + percent(0.1)\n```\n\n::: {.cell-output .cell-output-error}\n\n```\nError in `vec_arith()` at vctrs/R/type-vctr.R:650:5:\n! <percent> + <percent> is not permitted\n```\n\n\n:::\n:::\n\n\n## Math and arithmetic\n\nSince attendance is a simple numeric, the default `vec_math` method works fine. The default `vec_math` function is essentially:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvec_math.percent <- function(.fn, .x, ...) {\n  out <- vec_math_base(.fn, .x, ...)\n  vec_restore(out, .x)\n}\n```\n:::\n\n\n1. Apply the math to the underlying numbers\n2. Restore the percentage class\n\n## Math and arithmetic\n\nUnlike double dispatch in `vec_ptype2()` and `vec_cast()`, we currently need to implement our own secondary dispatch for `vec_arith()`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvec_arith.percent <- function(op, x, y, ...) {\n  UseMethod(\"vec_arith.percent\", y)\n}\nvec_arith.percent.default <- function(op, x, y, ...) {\n  stop_incompatible_op(op, x, y)\n}\n```\n:::\n\n\n## Math and arithmetic\n\nThen we can create methods for arithmetic.\n\n\\fontsize{10}{10}\\sf\n\n::: {.cell}\n\n```{.r .cell-code}\nvec_arith.percent.percent <- function(op, x, y, ...) {\n  out <- vec_arith_base(op, x, y)\n  vec_restore(out, to = percent())\n}\npercent(40) + percent(20)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n<percent[1]>\n[1] 60%\n```\n\n\n:::\n:::\n\n\n## Math and arithmetic\n\nThen we can create methods for arithmetic.\n\n\\fontsize{10}{10}\\sf\n\n::: {.cell}\n\n```{.r .cell-code}\nvec_arith.percent.numeric <- function(op, x, y, ...) {\n  out <- vec_arith_base(op, x, vec_cast(y, percent()))\n  vec_restore(out, to = percent())\n}\npercent(40) + 0.3\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n<percent[1]>\n[1] 70%\n```\n\n\n:::\n\n```{.r .cell-code}\n0.3 + percent(40)\n```\n\n::: {.cell-output .cell-output-error}\n\n```\nError in `vec_arith()` at vctrs/R/type-vctr.R:650:5:\n! <double> + <percent> is not permitted\n```\n\n\n:::\n:::\n\n\n\n## Math and arithmetic\n\nThen we can create methods for arithmetic.\n\n\\fontsize{10}{10}\\sf\n\n::: {.cell}\n\n```{.r .cell-code}\nvec_arith.numeric.percent <- function(op, x, y, ...) {\n  out <- vec_arith_base(op, vec_cast(x, percent()), y)\n  vec_restore(out, to = percent())\n}\npercent(40) + 0.3\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n<percent[1]>\n[1] 70%\n```\n\n\n:::\n\n```{.r .cell-code}\n0.3 + percent(40)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n<percent[1]>\n[1] 70%\n```\n\n\n:::\n:::\n\n\n\n## Math and arithmetic\n\n::: {.callout-caution title=\"Your turn!\"}\nAdd support for math and arithmetic for the `fraction` class.\n\n\\hspace{1em}\n\n*Hint: cast your fraction to a double and then use the base math/arith function, returning a double is fine*.\n\n\\hspace{1em}\n*Finished early?*\n\nTry to extend `vec_arith()` so that it retains the `fraction` class for `+`, `-`, `*`, `/` operations.\n:::\n",
    "supporting": [
      "slides_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": null,
    "postProcess": false
  }
}