{
  "hash": "71cb0cc4bef4ea67a8e0a9c96ce2aaa6",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: ETC4500/ETC5450 Advanced&nbsp;R&nbsp;programming\nauthor: \"Week 1: Foundations of R programming\"\nformat:\n  presentation-beamer:\n    fontsize: \"14pt,t\"\n    section-titles: false\n    knitr:\n      opts_chunk:\n        dev: \"cairo_pdf\"\n    fig-width: 7.5\n    fig-height: 3.5\n    include-in-header: ../header.tex\n    keep-tex: false\n---\n\n\n\n## Introduction\n\n### Expectations\n\n* You know R and RStudio\n* You have a basic understanding of programming (for loops, if statements, functions)\n* You can use Git and GitHub (https://happygitwithr.com)\n\n### Unit resources\n\n* Everything on **https://arp.numbat.space**\n* Assignments submitted on Github Classroom\n* Discussion on Ed\n\n## GitHub\n\n* Use your monash edu address.\n* Apply to GitHub Global Campus as a student (<https://github.com/education/students>).\n* Gives you free access to private repos and GitHub Copilot.\n* Add GitHub Copilot to RStudio settings.\n\n## R history\n\n* S (1976, Chambers, Becker and Wilks; Bell Labs, USA)\n* S-PLUS (1988, Doug Martin; Uni of Washington, USA)\n* R (1993, Ihaka and Gentleman; Uni of Auckland, NZ)\n\n\\pause\\vspace*{0.4cm}\n\n### R influenced by\n\n* Lisp (functional programming, environments, dynamic typing)\n* Scheme (functional programming, lexical scoping)\n* S and S-PLUS (syntax)\n\n## Why R?\n\n* Free, open source, and on every major platform.\n* A diverse and welcoming community\n* A massive set of packages, often cutting-edge.\n* Powerful communication tools (Shiny, Rmarkdown, \\rlap{quarto)}\n* RStudio and Positron IDEs\n* Deep-seated language support for data analysis.\n* A strong foundation of functional programming.\n* Posit\n* Easy connection to high-performance programming languages\n  like C, Fortran, and C++.\n\n## R challenges\n\n* R users are not usually programmers. Most R code by ordinary users is not very elegant, fast, or easy to understand.\n* R users more focused on results than good software practices.\n* R packages are inconsistent in design.\n* R can be slow.\n\n# Scalars and vectors\n\n## Scalars\n\n* **Logicals**: `TRUE` or `FALSE`, or abbreviated (`T` or `F`).\n\n* **Doubles**: decimal (`0.1234`), scientific (`1.23e4`), or hexadecimal (`0xcafe`). Special values: `Inf`, `-Inf`, and `NaN` (not a number).\n\n* **Integers**: `1234L`, `1e4L`, or `0xcafeL`. Can not contain fractional values.\n\n* **Strings**: `\"hi\"` or `'bye'`. Special characters are escaped with `\\`.\n\n## Making longer vectors with `c()` {#atomic-constructing}\n\nUse `c()` to create vectors.\n\n::: {.cell}\n\n```{.r .cell-code}\nlgl_var <- c(TRUE, FALSE)\nint_var <- c(1L, 6L, 10L)\ndbl_var <- c(1, 2.5, 4.5)\nchr_var <- c(\"these are\", \"some strings\")\n```\n:::\nWhen the inputs are atomic vectors,\\newline `c()` always flattens.\n\n::: {.cell}\n\n```{.r .cell-code}\nc(c(1, 2), c(3, 4))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1 2 3 4\n```\n\n\n:::\n:::\n\n\\placefig{9.8}{2.5}{width=6cm}{../diagrams/vectors/atomic.png}\n\n## Atomic vectors\n\\vspace*{-0.2cm}\n\n* Four primary types of atomic vectors: `logical`, `double`, `integer`,  and `character` (which contains strings).\n* Two rare types: `complex`, `raw`.\n* Collectively `integer` and `double` vectors are known as `numeric` vectors\n* `NULL` is like a zero length vector\n* Scalars are just vectors of length 1\n* Every vector can also have __attributes__: a named list of arbitrary metadata.\n* The __dimension__ attribute turns vectors into matrices and arrays.\n* The __class__ attribute powers the S3 object system.\n\n\n## Types and length\n\\fontsize{13}{13}\\sf\n\nYou can determine the type of a vector with `typeof()` and its length with `length()`.\n\n\\fontsize{10}{10}\\sf\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntypeof(lgl_var)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"logical\"\n```\n\n\n:::\n\n```{.r .cell-code}\ntypeof(int_var)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"integer\"\n```\n\n\n:::\n\n```{.r .cell-code}\ntypeof(dbl_var)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"double\"\n```\n\n\n:::\n\n```{.r .cell-code}\ntypeof(chr_var)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"character\"\n```\n\n\n:::\n:::\n\n## Missing values\n\nMost computations involving a missing value will return another missing value.\n\n\\fontsize{10}{10}\\sf\n\n::: {.cell}\n\n```{.r .cell-code}\nNA > 5\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] NA\n```\n\n\n:::\n\n```{.r .cell-code}\n10 * NA\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] NA\n```\n\n\n:::\n\n```{.r .cell-code}\n!NA\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] NA\n```\n\n\n:::\n:::\n\n## Missing values\n\nExceptions:\n\n\\fontsize{10}{10}\\sf\n\n::: {.cell}\n\n```{.r .cell-code}\nNA ^ 0\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1\n```\n\n\n:::\n\n```{.r .cell-code}\nNA | TRUE\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n\n```{.r .cell-code}\nNA & FALSE\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE\n```\n\n\n:::\n:::\n\n## Missing values\n\nUse `is.na()` to check for missingness\n\n\\fontsize{10}{10}\\sf\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- c(NA, 5, NA, 10)\nx == NA\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] NA NA NA NA\n```\n\n\n:::\n\n```{.r .cell-code}\nis.na(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  TRUE FALSE  TRUE FALSE\n```\n\n\n:::\n:::\n\n\\fontsize{13}{14}\\sf\n\nThere are actually four missing values:  `NA` (logical), `NA_integer_` (integer), `NA_real_` (double), and `NA_character_` (character).\n\n## Coercion\n\\fontsize{13}{14}\\sf\\vspace*{-0.25cm}\n\n* For atomic vectors, all elements must be the same type.\n* When you combine different types they are __coerced__ in a fixed order: logical → integer → double → character.\n\n\\fontsize{10}{4}\\sf\n\n::: {.cell}\n\n```{.r .cell-code}\nstr(c(\"a\", 1))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n chr [1:2] \"a\" \"1\"\n```\n\n\n:::\n\n```{.r .cell-code}\nx <- c(FALSE, FALSE, TRUE)\nas.numeric(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0 0 1\n```\n\n\n:::\n\n```{.r .cell-code}\nsum(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1\n```\n\n\n:::\n\n```{.r .cell-code}\nas.integer(c(\"1\", \"1.5\", \"a\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  1  1 NA\n```\n\n\n:::\n:::\n\n## Exercises\n\n1.  Predict the output of the following:\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    c(1, FALSE)\n    c(\"a\", 1)\n    c(TRUE, 1L)\n    ```\n    :::\n\n2. Why is `1 == \"1\"` true? Why is `-1 < FALSE` true? Why is `\"one\" < 2` false?\n\n3. Why is the default missing value, `NA`, a logical vector? What's special\n   about logical vectors? (Hint: think about `c(FALSE, NA_character_)`.)\n\n## Getting and setting attributes\n\n* You can think of attributes as name-value pairs that attach metadata to an object.\n* Individual attributes can be retrieved and modified with `attr()`, or retrieved en masse with `attributes()`, and set en masse with `structure()`.\n\n\\fontsize{10}{10}\\sf\n\n::: {.cell}\n\n```{.r .cell-code}\na <- 1:3\nattr(a, \"x\") <- \"abcdef\"\na\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1 2 3\nattr(,\"x\")\n[1] \"abcdef\"\n```\n\n\n:::\n:::\n\n## Getting and setting attributes\n\\fontsize{10}{10}\\sf\n\n::: {.cell}\n\n```{.r .cell-code}\nattr(a, \"y\") <- 4:6\nstr(attributes(a))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nList of 2\n $ x: chr \"abcdef\"\n $ y: int [1:3] 4 5 6\n```\n\n\n:::\n\n```{.r .cell-code}\n# Or equivalently\na <- structure(\n  1:3,\n  x = \"abcdef\",\n  y = 4:6\n)\nstr(attributes(a))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nList of 2\n $ x: chr \"abcdef\"\n $ y: int [1:3] 4 5 6\n```\n\n\n:::\n:::\n\n\\placefig{10}{1}{width=3.5cm}{../diagrams/vectors/attr.png}\n\n## Names {#attr-names}\n\n* Names are a type of attribute.\n* You can name a vector in three ways:\n\n\\fontsize{10}{10}\\sf\n\n::: {.cell}\n\n```{.r .cell-code}\n# When creating it:\nx <- c(a = 1, b = 2, c = 3)\n\n# By assigning a character vector to names()\nx <- 1:3\nnames(x) <- c(\"a\", \"b\", \"c\")\n\n# Inline, with setNames():\nx <- setNames(1:3, c(\"a\", \"b\", \"c\"))\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\na b c \n1 2 3 \n```\n\n\n:::\n:::\n\n## Names\n\n* Avoid using `attr(x, \"names\")` as it requires more typing and is less readable than `names(x)`.\n* You can remove names from a vector by using\\newline `x <- unname(x)` or `names(x) <- NULL`.\n\n\n## Dimensions {#attr-dims}\n\n* Adding a `dim` attribute to a vector allows it to behave like a 2-dimensional __matrix__ or a multi-dimensional __array__.\n* You can create matrices and arrays with `matrix()` and `array()`, or by using the assignment form of `dim()`:\n\n::: {.cell}\n\n```{.r .cell-code}\n# Two scalar arguments specify row and column sizes\nx <- matrix(1:6, nrow = 2, ncol = 3)\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2] [,3]\n[1,]    1    3    5\n[2,]    2    4    6\n```\n\n\n:::\n:::\n\n## Dimensions\n\n::: {.cell}\n\n```{.r .cell-code}\n# One vector argument to describe all dimensions\ny <- array(1:12, c(2, 3, 2))\ny\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n, , 1\n\n     [,1] [,2] [,3]\n[1,]    1    3    5\n[2,]    2    4    6\n\n, , 2\n\n     [,1] [,2] [,3]\n[1,]    7    9   11\n[2,]    8   10   12\n```\n\n\n:::\n:::\n\n## Dimensions\n\n::: {.cell}\n\n```{.r .cell-code}\n# You can also modify an object in place by setting dim()\nz <- 1:6\ndim(z) <- c(3, 2)\nz\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2]\n[1,]    1    4\n[2,]    2    5\n[3,]    3    6\n```\n\n\n:::\n:::\n\n## Exercises\n\n4. What does `dim()` return when applied to a 1-dimensional vector?\n5. When might you use `NROW()` or `NCOL()`?\n6. How would you describe the following three objects? What makes them different from `1:5`?\n\n   ::: {.cell}\n   \n   ```{.r .cell-code}\n   x1 <- array(1:5, c(1, 1, 5))\n   x2 <- array(1:5, c(1, 5, 1))\n   x3 <- array(1:5, c(5, 1, 1))\n   ```\n   :::\n\n## S3 atomic vectors\n\n* `class` is a vector attribute.\n* It turns object into __S3 object__.\n* Four important S3 vectors:\n\n  * **factor** vectors.\n  * **Date** vectors with day resolution.\n  * **POSIXct** vectors for date-times.\n  * **difftime** vectors for durations.\n\n\\placefig{10}{2}{width=6cm}{../diagrams/vectors/summary-tree-s3-1.png}\n\n## Factors\n\n* A vector that can contain only predefined values.\n* Used to store categorical data.\n* Built on top of an integer vector with two attributes: a `class`, \"factor\", and `levels`, which defines the set of allowed values.\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- factor(c(\"a\", \"b\", \"b\", \"a\"))\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] a b b a\nLevels: a b\n```\n\n\n:::\n:::\n\n## Factors\n\n::: {.cell}\n\n```{.r .cell-code}\ntypeof(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"integer\"\n```\n\n\n:::\n\n```{.r .cell-code}\nattributes(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$levels\n[1] \"a\" \"b\"\n\n$class\n[1] \"factor\"\n```\n\n\n:::\n:::\n\n\\placefig{10}{2}{width=5cm}{../diagrams/vectors/factor.png}\n\n## Factors\n\n::: {.cell}\n\n```{.r .cell-code}\nsex_char <- c(\"m\", \"m\", \"m\")\nsex_factor <- factor(sex_char, levels = c(\"m\", \"f\"))\n\ntable(sex_char)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nsex_char\nm \n3 \n```\n\n\n:::\n\n```{.r .cell-code}\ntable(sex_factor)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nsex_factor\nm f \n3 0 \n```\n\n\n:::\n:::\n\n## Factors\n\n* Be careful: some functions convert factors to integers!\n* ggplot preserves ordering of levels in graphs -- useful to reorder panels or legends.\n* Ordered factors are useful when the order of levels is meaningful.\n\n::: {.cell}\n\n```{.r .cell-code}\ngrade <- ordered(c(\"b\", \"b\", \"a\", \"c\"), levels = c(\"c\", \"b\", \"a\"))\ngrade\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] b b a c\nLevels: c < b < a\n```\n\n\n:::\n:::\n\n## Dates\n\n* Date vectors are built on top of double vectors.\n* Class \"Date\" with no other attributes:\n\n::: {.cell}\n\n```{.r .cell-code}\ntoday <- Sys.Date()\n\ntypeof(today)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"double\"\n```\n\n\n:::\n\n```{.r .cell-code}\nattributes(today)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$class\n[1] \"Date\"\n```\n\n\n:::\n:::\n\n## Dates\n\nThe value of the double (which can be seen by stripping the class), represents the number of days since 1970-01-01 (the \"Unix Epoch\").\n\n::: {.cell}\n\n```{.r .cell-code}\ndate <- as.Date(\"1970-02-01\")\nunclass(date)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 31\n```\n\n\n:::\n:::\n\n## Date-times\n\n* Base R provides two ways of storing date-time information, POSIXct, and POSIXlt.\n* \"POSIX\" is short for Portable Operating System Interface\n* \"ct\" stands for calendar time; \"lt\" for local time\n* POSIXct vectors are built on top of double vectors, where the value represents the number of seconds since 1970-01-01.\n\n::: {.cell}\n\n```{.r .cell-code}\nnow_ct <- as.POSIXct(\"2018-08-01 22:00\", tz = \"UTC\")\nnow_ct\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"2018-08-01 22:00:00 UTC\"\n```\n\n\n:::\n\n```{.r .cell-code}\ntypeof(now_ct)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"double\"\n```\n\n\n:::\n\n```{.r .cell-code}\nattributes(now_ct)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$class\n[1] \"POSIXct\" \"POSIXt\" \n\n$tzone\n[1] \"UTC\"\n```\n\n\n:::\n:::\n\n## Date-times\n\nThe `tzone` attribute controls only how the date-time is formatted; it does not control the instant of time represented by the vector. Note that the time is not printed if it is midnight.\n\n\\fontsize{10}{10}\\sf\n\n::: {.cell}\n\n```{.r .cell-code}\nstructure(now_ct, tzone = \"Asia/Tokyo\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"2018-08-02 07:00:00 JST\"\n```\n\n\n:::\n\n```{.r .cell-code}\nstructure(now_ct, tzone = \"America/New_York\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"2018-08-01 18:00:00 EDT\"\n```\n\n\n:::\n\n```{.r .cell-code}\nstructure(now_ct, tzone = \"Australia/Lord_Howe\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"2018-08-02 08:30:00 +1030\"\n```\n\n\n:::\n:::\n\n\n## Exercises\n\n7. What sort of object does `table()` return? What is its type? What\n    attributes does it have? How does the dimensionality change as you\n    tabulate more variables?\n\n8. What happens to a factor when you modify its levels?\n\n   ::: {.cell}\n   \n   ```{.r .cell-code}\n   f1 <- factor(letters)\n   levels(f1) <- rev(levels(f1))\n   ```\n   :::\n\n9. What does this code do? How do `f2` and `f3` differ from `f1`?\n\n   ::: {.cell}\n   \n   ```{.r .cell-code}\n   f2 <- rev(factor(letters))\n   f3 <- factor(letters, levels = rev(letters))\n   ```\n   :::\n\n# Lists and data frames\n## Lists\n\n* More complex than atomic vectors\n* Elements are *references* to objects of any type\n\n\\fontsize{10}{10}\\sf\n\n::: {.cell}\n\n```{.r .cell-code}\nl1 <- list(\n  1:3, \"a\", c(TRUE, FALSE, TRUE), c(2.3, 5.9)\n)\ntypeof(l1)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"list\"\n```\n\n\n:::\n\n```{.r .cell-code}\nstr(l1)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nList of 4\n $ : int [1:3] 1 2 3\n $ : chr \"a\"\n $ : logi [1:3] TRUE FALSE TRUE\n $ : num [1:2] 2.3 5.9\n```\n\n\n:::\n:::\n\n\\placefig{10}{3.5}{width=5cm}{../diagrams/vectors/list.png}\n\n## Lists\n\n* Lists can be recursive:  a list can contain other lists.\n\n::: {.cell}\n\n```{.r .cell-code}\nl3 <- list(list(list(1)))\nstr(l3)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nList of 1\n $ :List of 1\n  ..$ :List of 1\n  .. ..$ : num 1\n```\n\n\n:::\n:::\n\n\\placefig{10}{4}{width=5cm}{../diagrams/vectors/list-recursive.png}\n\n## Lists\n\n* `c()` will combine several lists into one.\n\n\\fontsize{9}{9}\\sf\n\n::: {.cell}\n\n```{.r .cell-code}\nl4 <- list(list(1, 2), c(3, 4))\nl5 <- c(list(1, 2), c(3, 4))\nstr(l4)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nList of 2\n $ :List of 2\n  ..$ : num 1\n  ..$ : num 2\n $ : num [1:2] 3 4\n```\n\n\n:::\n\n```{.r .cell-code}\nstr(l5)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nList of 4\n $ : num 1\n $ : num 2\n $ : num 3\n $ : num 4\n```\n\n\n:::\n:::\n\n\\placefig{10}{3}{width=5cm}{../diagrams/vectors/list-c.png}\n\n## Testing and coercion {#list-types}\n\n\\fontsize{9}{9}\\sf\n\n::: {.cell}\n\n```{.r .cell-code}\nlist(1:3)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[[1]]\n[1] 1 2 3\n```\n\n\n:::\n\n```{.r .cell-code}\nas.list(1:3)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[[1]]\n[1] 1\n\n[[2]]\n[1] 2\n\n[[3]]\n[1] 3\n```\n\n\n:::\n:::\n\n\\fontsize{13}{14}\\sf\n\n* You can turn a list into an atomic vector with `unlist()`.\n\n## Data frames and tibbles {#tibble}\n\\vspace*{-0.2cm}\n\\placefig{12.2}{0.35}{width=3cm}{../diagrams/vectors/summary-tree-s3-2.png}\n\n* Most important S3 vectors built on lists:\\newline data frames and tibbles.\n\n\\fontsize{10}{8}\\sf\n\n::: {.cell}\n\n```{.r .cell-code}\ndf1 <- data.frame(x = 1:3, y = letters[1:3])\ntypeof(df1)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"list\"\n```\n\n\n:::\n\n```{.r .cell-code}\nattributes(df1)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$names\n[1] \"x\" \"y\"\n\n$class\n[1] \"data.frame\"\n\n$row.names\n[1] 1 2 3\n```\n\n\n:::\n:::\n\n\n\\placefig{5.5}{5.5}{width=2.5cm}{../diagrams/vectors/data-frame-2.png}\n\n\n## Data frames and tibbles\n\n* A data frame has a constraint: the length of each of its vectors must be the same.\n* A data frame has `rownames()` and `colnames()`. The `names()`\n  of a data frame are the column names.\n* A data frame has `nrow()` rows and `ncol()` columns. The `length()` of a\n  data frame gives the number of columns.\n\n## Tibbles\n\\fontsize{13}{14}\\sf\n\n* Modern reimagining of the data frame.\n* tibbles are \"lazy and surly\": they do less and complain more.\n\n\\fontsize{10}{8}\\sf\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tibble)\ndf2 <- tibble(x = 1:3, y = letters[1:3])\ntypeof(df2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"list\"\n```\n\n\n:::\n\n```{.r .cell-code}\nattributes(df2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$class\n[1] \"tbl_df\"     \"tbl\"        \"data.frame\"\n\n$row.names\n[1] 1 2 3\n\n$names\n[1] \"x\" \"y\"\n```\n\n\n:::\n:::\n\n\n## Creating data frames and tibbles\n\n::: {.cell}\n\n```{.r .cell-code}\nnames(data.frame(`1` = 1))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"X1\"\n```\n\n\n:::\n\n```{.r .cell-code}\nnames(tibble(`1` = 1))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"1\"\n```\n\n\n:::\n:::\n\n## Creating data frames and tibbles\n\n\\fontsize{10}{10}\\sf\n\n::: {.cell}\n\n```{.r .cell-code}\ndata.frame(x = 1:4, y = 1:2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  x y\n1 1 1\n2 2 2\n3 3 1\n4 4 2\n```\n\n\n:::\n\n```{.r .cell-code}\ntibble(x = 1:4, y = 1:2)\n```\n\n::: {.cell-output .cell-output-error}\n\n```\nError in `tibble()`:\n! Tibble columns must have compatible sizes.\n* Size 4: Existing data.\n* Size 2: Column `y`.\ni Only values of size one are recycled.\n```\n\n\n:::\n:::\n\n## Creating data frames and tibbles\n\\fontsize{10}{10}\\sf\n\n::: {.cell}\n\n```{.r .cell-code}\ntibble(\n  x = 1:3,\n  y = x * 2,\n  z = 5\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3 x 3\n      x     y     z\n  <int> <dbl> <dbl>\n1     1     2     5\n2     2     4     5\n3     3     6     5\n```\n\n\n:::\n:::\n\n\n## Row names {#rownames}\n\nData frames allow you to label each row with a name, a character vector containing only unique values:\n\n\\fontsize{10}{10}\\sf\n\n::: {.cell}\n\n```{.r .cell-code}\ndf3 <- data.frame(\n  age = c(35, 27, 18),\n  hair = c(\"blond\", \"brown\", \"black\"),\n  row.names = c(\"Bob\", \"Susan\", \"Sam\")\n)\ndf3\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n      age  hair\nBob    35 blond\nSusan  27 brown\nSam    18 black\n```\n\n\n:::\n:::\n\n## Row names\n\n* tibbles do not support row names\n* convert row names into a regular column with either `rownames_to_column()`, or the `rownames` argument:\n\n\\fontsize{10}{10}\\sf\n\n::: {.cell}\n\n```{.r .cell-code}\nas_tibble(df3, rownames = \"name\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3 x 3\n  name    age hair \n  <chr> <dbl> <chr>\n1 Bob      35 blond\n2 Susan    27 brown\n3 Sam      18 black\n```\n\n\n:::\n:::\n\n## Printing\n\n\\fontsize{10}{9.5}\\sf\n\n::: {.cell}\n\n```{.r .cell-code}\ndplyr::starwars\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 87 x 14\n   name       height  mass hair_color skin_color eye_color birth_year sex  \n   <chr>       <int> <dbl> <chr>      <chr>      <chr>          <dbl> <chr>\n 1 Luke Skyw~    172    77 blond      fair       blue            19   male \n 2 C-3PO         167    75 <NA>       gold       yellow         112   none \n 3 R2-D2          96    32 <NA>       white, bl~ red             33   none \n 4 Darth Vad~    202   136 none       white      yellow          41.9 male \n 5 Leia Orga~    150    49 brown      light      brown           19   fema~\n 6 Owen Lars     178   120 brown, gr~ light      blue            52   male \n 7 Beru Whit~    165    75 brown      light      blue            47   fema~\n 8 R5-D4          97    32 <NA>       white, red red             NA   none \n 9 Biggs Dar~    183    84 black      light      brown           24   male \n10 Obi-Wan K~    182    77 auburn, w~ fair       blue-gray       57   male \n# i 77 more rows\n# i 6 more variables: gender <chr>, homeworld <chr>, species <chr>,\n#   films <list>, vehicles <list>, starships <list>\n```\n\n\n:::\n:::\n\n## Printing\n\n* Tibbles only show first 10 rows and all columns that fit on\n  screen. Additional columns shown at bottom.\n* Each column labelled with its type, abbreviated to 3--4 letters.\n* Wide columns truncated.\n\n## List columns\n\n\\fontsize{10}{10}\\sf\n\n::: {.cell}\n\n```{.r .cell-code}\ndf <- data.frame(x = 1:3)\ndf$y <- list(1:2, 1:3, 1:4)\ndf\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  x          y\n1 1       1, 2\n2 2    1, 2, 3\n3 3 1, 2, 3, 4\n```\n\n\n:::\n:::\n\n\\placefig{10}{1.5}{width=5cm}{../diagrams/vectors/data-frame-list.png}\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntibble(\n  x = 1:3,\n  y = list(1:2, 1:3, 1:4)\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3 x 2\n      x y        \n  <int> <list>   \n1     1 <int [2]>\n2     2 <int [3]>\n3     3 <int [4]>\n```\n\n\n:::\n:::\n\n## Matrix and data frame columns\n\n::: {.cell}\n\n```{.r .cell-code}\ndfm <- tibble(\n  x = 1:3 * 10,\n  y = matrix(1:9, nrow = 3),\n  z = data.frame(a = 3:1, b = letters[1:3])\n)\nstr(dfm)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\ntibble [3 x 3] (S3: tbl_df/tbl/data.frame)\n $ x: num [1:3] 10 20 30\n $ y: int [1:3, 1:3] 1 2 3 4 5 6 7 8 9\n $ z:'data.frame':\t3 obs. of  2 variables:\n  ..$ a: int [1:3] 3 2 1\n  ..$ b: chr [1:3] \"a\" \"b\" \"c\"\n```\n\n\n:::\n:::\n\n\\placefig{10}{1.25}{width=5cm}{../diagrams/vectors/data-frame-matrix.png}\n\n## Exercises\n\n10.  What happens if you attempt to set rownames that are not unique?\n11.  If `df` is a data frame, what can you say about `t(df)`, and `t(t(df))`?\n    Perform some experiments, making sure to try different column types.\n12.  What does `as.matrix()` do when applied to a data frame with\n    columns of different types? How does it differ from `data.matrix()`?\n\n## `NULL`\n\n::: {.cell}\n\n```{.r .cell-code}\nlength(NULL)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0\n```\n\n\n:::\n:::\n\nYou can test for `NULL`s with `is.null()`:\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- NULL\nx == NULL\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nlogical(0)\n```\n\n\n:::\n\n```{.r .cell-code}\nis.null(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n:::\n\n# Subsetting\n\n## Exercises\n\n13. What is the result of subsetting a vector with positive integers, negative integers, a logical vector, or a character vector?\n14. What's the difference between `[`, `[[`, and `$` when applied to a list?\n15. When should you use `drop = FALSE`?\n\n## Exercises\n\\fontsize{13}{14}\\sf\n\n16. Fix each of the following common data frame subsetting errors:\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    mtcars[mtcars$cyl = 4, ]\n    mtcars[-1:4, ]\n    mtcars[mtcars$cyl <= 5]\n    mtcars[mtcars$cyl == 4 | 6, ]\n    ```\n    :::\n\n17. Extract the residual degrees of freedom from `mod`\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    mod <- lm(mpg ~ wt, data = mtcars)\n    ```\n    :::\n\n18. Extract the R squared from the model summary (`summary(mod)`)\n\n## Exercises\n\n19. How would you randomly permute the columns of a data frame?\n\n20. How would you select a random sample of m rows from a data frame? What if the sample had to be contiguous (i.e., with an initial row, a final row, and every row in between)?\n\n21. How could you put the columns in a data frame in alphabetical order?\n\n# Functions\n\n## Function fundamentals\n\n* Almost all functions can be broken down into three components: arguments, body, and environment.\n\n  * The `formals()`, the list of arguments that control how you call the function.\n  * The `body()`, the code inside the function.\n  * The `environment()`, the data structure that determines how the function finds the values associated with the names.\n\n* Functions are objects and have attributes.\n\n## Function components\n\\fontsize{10}{5}\\sf\n\n::: {.cell}\n\n```{.r .cell-code}\nf02 <- function(x, y) {\n  # A comment\n  x + y\n}\nformals(f02)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$x\n\n\n$y\n```\n\n\n:::\n\n```{.r .cell-code}\nbody(f02)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n{\n    x + y\n}\n```\n\n\n:::\n\n```{.r .cell-code}\nenvironment(f02)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n<environment: R_GlobalEnv>\n```\n\n\n:::\n:::\n\n## Invoking a function\n\\fontsize{10}{10}\\sf\n\n::: {.cell}\n\n```{.r .cell-code}\nmean(1:10, na.rm = TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 5.5\n```\n\n\n:::\n\n```{.r .cell-code}\nmean(, TRUE, x = 1:10)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 5.5\n```\n\n\n:::\n\n```{.r .cell-code}\nargs <- list(1:10, na.rm = TRUE)\ndo.call(mean, args)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 5.5\n```\n\n\n:::\n:::\n\n## Function composition {#function-composition}\n\\fontsize{13}{15}\\sf\n\n::: {.cell}\n\n```{.r .cell-code}\nsquare <- function(x) { x^2 }\ndeviation <- function(x) { x - mean(x) }\nx <- runif(100)\n```\n:::\n\n:::: {.columns}\n::: {.column width=\"50%\"}\n\nNesting:\n\n::: {.cell}\n\n```{.r .cell-code}\nsqrt(mean(square(deviation(x))))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.274\n```\n\n\n:::\n:::\n\nIntermediate variables:\n\n::: {.cell}\n\n```{.r .cell-code}\nout <- deviation(x)\nout <- square(out)\nout <- mean(out)\nout <- sqrt(out)\nout\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.274\n```\n\n\n:::\n:::\n:::\n\n::: {.column width=\"50%\"}\n\nPipe:\n\n::: {.cell}\n\n```{.r .cell-code}\nx |>\n  deviation() |>\n  square() |>\n  mean() |>\n  sqrt()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.274\n```\n\n\n:::\n:::\n\n:::\n::::\n\n## Lexical scoping {#lexical-scoping}\n\nNames defined inside a function mask names defined outside a function.\n\n\\fontsize{10}{10}\\sf\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- 10\ny <- 20\ng02 <- function() {\n  x <- 1\n  y <- 2\n  c(x, y)\n}\ng02()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1 2\n```\n\n\n:::\n:::\n\n## Lexical scoping\n\nNames defined inside a function mask names defined outside a function.\n\n\\fontsize{10}{10}\\sf\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- 2\ng03 <- function() {\n  y <- 1\n  c(x, y)\n}\ng03()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 2 1\n```\n\n\n:::\n\n```{.r .cell-code}\n# And this doesn't change the previous value of y\ny\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 20\n```\n\n\n:::\n:::\n\n## Lexical scoping\n\nNames defined inside a function mask names defined outside a function.\n\n\\fontsize{10}{10}\\sf\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- 1\ng04 <- function() {\n  y <- 2\n  i <- function() {\n    z <- 3\n    c(x, y, z)\n  }\n  i()\n}\ng04()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1 2 3\n```\n\n\n:::\n:::\n\n## Functions versus variables\n\\fontsize{10}{10}\\sf\n\n::: {.cell}\n\n```{.r .cell-code}\ng07 <- function(x) { x + 1 }\ng08 <- function() {\n  g07 <- function(x) { x + 100 }\n  g07(10)\n}\ng08()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 110\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ng09 <- function(x) { x + 100 }\ng10 <- function() {\n  g09 <- 10\n  g09(g09)\n}\ng10()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 110\n```\n\n\n:::\n:::\n\n\n## A fresh start {#fresh-start}\n\nWhat happens to values between invocations of a function?\n\n::: {.cell}\n\n:::\n\n\\fontsize{10}{9}\\sf\n\n\n::: {.cell}\n\n```{.r .cell-code}\ng11 <- function() {\n  if (!exists(\"a\")) {\n    a <- 1\n  } else {\n    a <- a + 1\n  }\n  a\n}\n\ng11()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1\n```\n\n\n:::\n\n```{.r .cell-code}\ng11()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1\n```\n\n\n:::\n:::\n\n## Dynamic lookup\n\\fontsize{10}{10}\\sf\n\n::: {.cell}\n\n```{.r .cell-code}\ng12 <- function() { x + 1 }\nx <- 15\ng12()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 16\n```\n\n\n:::\n\n```{.r .cell-code}\nx <- 20\ng12()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 21\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ncodetools::findGlobals(g12)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"{\" \"+\" \"x\"\n```\n\n\n:::\n:::\n\n\\pause\\alert{It is good practice to pass all the inputs to a function as arguments.}\n\n## Lazy evaluation {#lazy-evaluation}\n\nThis code doesn't generate an error because `x` is never used:\n\n::: {.cell}\n\n```{.r .cell-code}\nh01 <- function(x) {\n  10\n}\nh01(stop(\"This is an error!\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 10\n```\n\n\n:::\n:::\n\n## Promises\n\\fontsize{13}{14}\\sf\n\nLazy evaluation is powered by a data structure called a __promise__.\n\nA promise has three components:\n\n*   An expression, like `x + y`, which gives rise to the delayed computation.\n\n*   An environment where the expression should be evaluated\n\n*   A value, which is computed and cached the first time a promise is\n    accessed when the expression is evaluated in the specified environment.\n\n## Promises\n\\fontsize{10}{10}\\sf\n\n::: {.cell}\n\n```{.r .cell-code}\ny <- 10\nh02 <- function(x) {\n  y <- 100\n  x + 1\n}\nh02(y)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 11\n```\n\n\n:::\n:::\n\n## Promises\n\\fontsize{10}{10}\\sf\n\n::: {.cell}\n\n```{.r .cell-code}\ndouble <- function(x) {\n  message(\"Calculating...\")\n  x * 2\n}\nh03 <- function(x) {\n  c(x, x)\n}\nh03(double(20))\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nCalculating...\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 40 40\n```\n\n\n:::\n:::\n\n\\pause\\fontsize{13}{15}\\sf\n\nPromises are like a quantum state: any attempt to inspect them with R code will force an immediate evaluation, making the promise disappear.\n\n## Default arguments\n\nThanks to lazy evaluation, default values can be defined in terms of other arguments, or even in terms of variables defined later in the function:\n\n\\fontsize{10}{10}\\sf\n\n::: {.cell}\n\n```{.r .cell-code}\nh04 <- function(x = 1, y = x * 2, z = a + b) {\n  a <- 10\n  b <- 100\n  c(x, y, z)\n}\nh04()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]   1   2 110\n```\n\n\n:::\n:::\n\n\\pause\\alert{Not recommended!}\n\n## `...`  (dot-dot-dot) {#fun-dot-dot-dot}\n\nAllows for any number of additional arguments.\n\nYou can use `...` to pass additional arguments to another function.\n\\fontsize{10}{10}\\sf\n\n::: {.cell}\n\n```{.r .cell-code}\ni01 <- function(y, z) {\n  list(y = y, z = z)\n}\ni02 <- function(x, ...) {\n  i01(...)\n}\nstr(i02(x = 1, y = 2, z = 3))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nList of 2\n $ y: num 2\n $ z: num 3\n```\n\n\n:::\n:::\n\n## `...`  (dot-dot-dot)\n\n`list(...)` evaluates the arguments and stores them in a list:\\fontsize{10}{10}\\sf\n\n\n::: {.cell}\n\n```{.r .cell-code}\ni04 <- function(...) {\n  list(...)\n}\nstr(i04(a = 1, b = 2))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nList of 2\n $ a: num 1\n $ b: num 2\n```\n\n\n:::\n:::\n\n## `...`  (dot-dot-dot)\n\\fontsize{13}{14}\\sf\n\n*   Allows you to pass arguments to a function called within your function, without having to list them all explicitly.\n\n\\pause\\alert{Two downsides:}\n\n*   When you use it to pass arguments to another function, you have to\n    carefully explain to the user where those arguments go.\n*   A misspelled argument will not raise an error. This makes it easy for\n    typos to go unnoticed:\n\n\\fontsize{10}{5}\\sf\n\n::: {.cell}\n\n```{.r .cell-code}\nsum(1, 2, NA, na_rm = TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] NA\n```\n\n\n:::\n:::\n\n## Exercises\n\n22. Explain the following results: \\fontsize{10}{10}\\sf\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    sum(1, 2, 3)\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    \n    ```\n    [1] 6\n    ```\n    \n    \n    :::\n    \n    ```{.r .cell-code}\n    mean(1, 2, 3)\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    \n    ```\n    [1] 1\n    ```\n    \n    \n    :::\n    \n    ```{.r .cell-code}\n    sum(1, 2, 3, na.omit = TRUE)\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    \n    ```\n    [1] 7\n    ```\n    \n    \n    :::\n    \n    ```{.r .cell-code}\n    mean(1, 2, 3, na.omit = TRUE)\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    \n    ```\n    [1] 1\n    ```\n    \n    \n    :::\n    :::\n\n\n## Exiting a function\n\nMost functions exit in one of two ways:\n\n* return a value, indicating success\n* throw an error, indicating failure.\n\n## Implicit versus explicit returns\n\nImplicit return, where the last evaluated expression is the return value:\n\n\\fontsize{10}{5}\\sf\n\n::: {.cell}\n\n```{.r .cell-code}\nj01 <- function(x) {\n  if (x < 10) {\n    0\n  } else {\n    10\n  }\n}\nj01(5)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0\n```\n\n\n:::\n\n```{.r .cell-code}\nj01(15)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 10\n```\n\n\n:::\n:::\n\n## Implicit versus explicit returns\n\nExplicit return, by calling `return()`:\n\n\\fontsize{10}{5}\\sf\n\n::: {.cell}\n\n```{.r .cell-code}\nj02 <- function(x) {\n  if (x < 10) {\n    return(0)\n  } else {\n    return(10)\n  }\n}\nj02(5)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0\n```\n\n\n:::\n\n```{.r .cell-code}\nj02(15)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 10\n```\n\n\n:::\n:::\n\n## Invisible values {#invisible}\n\nMost functions return visibly: calling the function in an interactive context prints the result.\n\n::: {.cell}\n\n```{.r .cell-code}\nj03 <- function() { 1 }\nj03()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1\n```\n\n\n:::\n:::\n\nHowever, you can prevent automatic printing by applying `invisible()` to the last value:\n\n::: {.cell}\n\n```{.r .cell-code}\nj04 <- function() { invisible(1) }\nj04()\n```\n:::\n\n## Invisible values {#invisible2}\n\nThe most common function that returns invisibly is `<-`:\n\n::: {.cell}\n\n```{.r .cell-code}\na <- 2\n(a <- 2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 2\n```\n\n\n:::\n:::\n\nThis is what makes it possible to chain assignments:\n\n::: {.cell}\n\n```{.r .cell-code}\na <- b <- c <- d <- 2\n```\n:::\n\nIn general, any function called primarily for a side effect (like `<-`, `print()`, or `plot()`) should return an invisible value (typically the value of the first argument).\n\n## Errors\n\nIf a function cannot complete its assigned task, it should throw an error with `stop()`, which immediately terminates the execution of the function.\n\n\\fontsize{10}{10}\\sf\n\n::: {.cell}\n\n```{.r .cell-code}\nj05 <- function() {\n  stop(\"I'm an error\")\n  return(10)\n}\nj05()\n```\n\n::: {.cell-output .cell-output-error}\n\n```\nError in j05(): I'm an error\n```\n\n\n:::\n:::\n\n\n\n## Function forms\n\n###\n> To understand computations in R, two slogans are helpful:\n>\n> * Everything that exists is an object.\n> * Everything that happens is a function call.\n>\n> --- John Chambers\n\n## Function forms\n\n* __prefix__: the function name comes before its arguments, like\n  `foofy(a, b, c)`.\n* __infix__: the function name comes in between its arguments, like\n  `x + y`.\n* __replacement__: functions that replace values by assignment, like\n  `names(df) <- c(\"a\", \"b\", \"c\")`.\n* __special__: functions like `[[`, `if`, and `for`.\n\n## Rewriting to prefix form {#prefix-transform}\n\nEverything can be written in prefix form.\n\n::: {.cell}\n\n```{.r .cell-code}\nx + y\n`+`(x, y)\n\nnames(df) <- c(\"x\", \"y\", \"z\")\n`names<-`(df, c(\"x\", \"y\", \"z\"))\n\nfor(i in 1:10) print(i)\n`for`(i, 1:10, print(i))\n```\n:::\n\n## Don't be evil!\n\n::: {.cell}\n\n```{.r .cell-code}\n`(` <- function(e1) {\n  if (is.numeric(e1) && runif(1) < 0.1) {\n    e1 + 1\n  } else {\n    e1\n  }\n}\nreplicate(50, (1 + 2))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] 3 3 3 3 4 3 3 3 3 3 3 3 3 3 3 3 3 4 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3\n[36] 4 3 3 3 3 3 4 3 3 3 3 4 3 3 3\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n:::\n\n## Prefix form {#prefix-form}\n\nYou can specify arguments in three ways:\n\n* By position, like `help(mean)`.\n* By name, like `help(topic = mean)`.\n* Using partial matching, like `help(top = mean)`.\n\n## Exercises\n\n23. Clarify the following list of odd function calls:\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    x <- sample(replace = TRUE, 20, x = c(1:10, NA))\n    y <- runif(min = 0, max = 1, 20)\n    cor(m = \"k\", y = y, u = \"p\", x = x)\n    ```\n    :::\n\n## Infix functions\n\nFunctions with 2 arguments, and the function name comes between the arguments:\n\n `:`, `::`, `:::`, `$`, `@`, `^`, `*`, `/`, `+`, `-`, `>`, `>=`, `<`, `<=`, `==`, `!=`, `!`, `&`, `&&`, `|`, `||`, `~`, `<-`, and `<<-`.\n\n::: {.cell}\n\n```{.r .cell-code}\n1 + 2\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 3\n```\n\n\n:::\n\n```{.r .cell-code}\n`+`(1, 2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 3\n```\n\n\n:::\n:::\n\n## Infix functions\n\nYou can also create your own infix functions that start and end with `%`.\n\n::: {.cell}\n\n```{.r .cell-code}\n`%+%` <- function(a, b) paste0(a, b)\n\"new \" %+% \"string\"\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"new string\"\n```\n\n\n:::\n:::\n\n## Replacement functions {#replacement-functions}\n\n* Replacement functions act like they modify their arguments in place, and have the special name `xxx<-`.\n* They must have arguments named `x` and `value`, and must return the modified object.\n\n::: {.cell}\n\n```{.r .cell-code}\n`second<-` <- function(x, value) {\n  x[2] <- value\n  x\n}\nx <- 1:10\nsecond(x) <- 5L\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1]  1  5  3  4  5  6  7  8  9 10\n```\n\n\n:::\n:::\n\n## Replacement functions\n\n::: {.cell}\n\n```{.r .cell-code}\n`modify<-` <- function(x, position, value) {\n  x[position] <- value\n  x\n}\nmodify(x, 1) <- 10\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] 10  5  3  4  5  6  7  8  9 10\n```\n\n\n:::\n:::\n\nWhen you write `modify(x, 1) <- 10`, behind the scenes R turns it into:\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- `modify<-`(x, 1, 10)\n```\n:::\n\n# Environments\n\n## Environment basics\n\nEnvironments are data structures that power scoping.\n\nAn environment is similar to a named list, with four important exceptions:\n\n* Every name must be unique.\n* The names in an environment are not ordered.\n* An environment has a parent.\n* Environments are not copied when modified.\n\n## Environment basics\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(rlang)\ne1 <- env(\n  a = FALSE,\n  b = \"a\",\n  c = 2.3,\n  d = 1:3,\n)\n```\n:::\n\n\\placefig{8}{1.9}{width=7cm}{../diagrams/environments/bindings.png}\n\n### Special environments\n\n* The **current environment** is the environment in which code is currently executing.\n* The **global environment** is where all interactive computation takes place. Your \"workspace\".\n\n## Parent environments\n\n:::: {.columns}\n::: {.column width=\"50%\"}\n\n* Every environment has a parent.\n* If a name is not found in an environment, R looks in the parent environment.\n* The ancestors of the global environment include every attached package.\n\n:::\n::: {.column width=\"50%\"}\n\\fontsize{10}{10}\\sf\\vspace*{-0.3cm}\n\n::: {.cell}\n\n```{.r .cell-code}\nenv_parents(e1, last = empty_env())\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [[1]] $ <env: global>\n [[2]] $ <env: package:rlang>\n [[3]] $ <env: package:tibble>\n [[4]] $ <env: package:dplyr>\n [[5]] $ <env: package:stats>\n [[6]] $ <env: package:graphics>\n [[7]] $ <env: package:grDevices>\n [[8]] $ <env: package:datasets>\n [[9]] $ <env: renv:shims>\n[[10]] $ <env: package:utils>\n[[11]] $ <env: package:methods>\n[[12]] $ <env: Autoloads>\n[[13]] $ <env: package:base>\n[[14]] $ <env: empty>\n```\n\n\n:::\n:::\n:::\n::::\n\n## Super assignment\n\n* Regular assignment (`<-`) creates a variable in the current environment.\n* Super assignment (`<<-`) modifies a variable in a parent environment.\n* If it can't find an existing variable, it creates one in the global environment.\n\n## Package environments\n\\fontsize{13}{15}\\sf\n\n* Every package attached becomes one of the parents of the global environment (in order of attachment).\\fontsize{10}{10}\\sf\n\n  ::: {.cell}\n  \n  ```{.r .cell-code}\n  search()\n  ```\n  \n  ::: {.cell-output .cell-output-stdout}\n  \n  ```\n   [1] \".GlobalEnv\"        \"package:rlang\"     \"package:tibble\"   \n   [4] \"package:dplyr\"     \"package:stats\"     \"package:graphics\" \n   [7] \"package:grDevices\" \"package:datasets\"  \"renv:shims\"       \n  [10] \"package:utils\"     \"package:methods\"   \"Autoloads\"        \n  [13] \"package:base\"     \n  ```\n  \n  \n  :::\n  :::\n\n\\fontsize{13}{15}\\sf\n\n* Attaching a package changes the parent of the global environment.\n* `Autoloads` uses delayed bindings to save memory by only loading package objects when needed.\n\n## Function environments\n\\fontsize{13}{14}\\sf\n\nA function binds the current environment when it is created.\n\n\\fontsize{10}{10}\\sf\n\n::: {.cell}\n\n```{.r .cell-code}\ny <- 1\nf <- function(x) {\n  env_print(current_env())\n  x + y\n}\nf(2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n<environment: 0x623543d8ba48>\nParent: <environment: global>\nBindings:\n* x: <lazy>\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 3\n```\n\n\n:::\n:::\n\n## Namespaces\n\\fontsize{13}{14}\\sf\n\n* Package environment: how an R user finds a function in an attached package (only includes exports)\n* Namespace environment: how a package finds its own objects (includes non-exports as well)\n* Each namespace environment has an imports environment (controlled via NAMESPACE file).\n\n::: {.cell}\n::: {.cell-output-display}\n![](../diagrams/environments/namespace-env.png){width=4.13in}\n:::\n:::\n\n## Caller environments\n\\fontsize{10}{10}\\sf\n\n::: {.cell}\n\n```{.r .cell-code}\nf <- function(x) {\n  g(x = 2)\n}\ng <- function(x) {\n  h(x = 3)\n}\nh <- function(x) {\n  stop()\n}\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nf(x = 1)\n#> Error: in h(x = 3)\ntraceback()\n#> 4: stop() at #3\n#> 3: h(x = 3) at #3\n#> 2: g(x = 2) at #3\n#> 1: f(x = 1)\n```\n:::\n\n## Lazy evaluation\n\n::: {.cell}\n\n```{.r .cell-code}\na <- function(x) b(x)\nb <- function(x) c(x)\nc <- function(x) x\na(f())\n#> Error: in h(x = 3)\ntraceback()\n#> 7: stop() at #3\n#> 6: h(x = 3) at #3\n#> 5: g(x = 2) at #3\n#> 4: f() at #1\n#> 3: c(x) at #1\n#> 2: b(x) at #1\n#> 1: a(f())\nunused argument (clas\n```\n:::\n\n\n# Conditions\n\n## Conditions\n\n```r\nmessage(\"This is what a message looks like\")\n#> This is what a message looks like\n\nwarning(\"This is what a warning looks like\")\n#> Warning: This is what a warning looks like\n\nstop(\"This is what an error looks like\")\n#> Error in eval(expr, envir, enclos): This is what an error looks like\n```\n\n\\pause\n\n* Ignore messages with `suppressMessages()`.\n* Ignore warnings with `suppressWarnings()`.\n* Ignore errors with `try()`.\n\n## try()\n\n* Allows execution to continue even if an error occurs.\n* Returns a special object that captures the error.\n\n\\fontsize{10}{10}\\sf\n\n:::: {.columns}\n::: {.column width=\"50%\"}\n\n::: {.cell}\n\n```{.r .cell-code}\nf1 <- function(x) {\n  log(x)\n  10\n}\nf1(\"x\")\n```\n\n::: {.cell-output .cell-output-error}\n\n```\nError in log(x): non-numeric argument to mathematical function\n```\n\n\n:::\n:::\n\n:::\n::: {.column width=\"50%\"}\n\n::: {.cell}\n\n```{.r .cell-code}\nf2 <- function(x) {\n  try(log(x))\n  10\n}\nf2(\"a\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nError in log(x) : non-numeric argument to mathematical function\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 10\n```\n\n\n:::\n:::\n\n:::\n::::\n\n## Handling conditions\n\\fontsize{13}{15}\\sf\n\nAllow you to specify what should happen when a condition occurs.\n\n::: {.cell}\n\n```{.r .cell-code}\ntryCatch(\n  error = function(cnd) {\n    # code to run when error is thrown\n  },\n  code_to_run_while_handlers_are_active\n)\nwithCallingHandlers(\n  warning = function(cnd) {\n    # code to run when warning is signalled\n  },\n  message = function(cnd) {\n    # code to run when message is signalled\n  },\n  code_to_run_while_handlers_are_active\n)\n```\n:::\n\n## tryCatch()\n\\fontsize{10}{10}\\sf\n\n::: {.cell}\n\n```{.r .cell-code}\nf3 <- function(x) {\n  tryCatch(\n    error = function(cnd) NA,\n    log(x)\n  )\n}\n\nf3(\"x\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] NA\n```\n\n\n:::\n:::\n\n\n## withCallingHandlers()\n\\fontsize{10}{10}\\sf\n\n::: {.cell}\n\n```{.r .cell-code}\nf4 <- function(x) {\n  withCallingHandlers(\n    warning = function(cnd) cat(\"How did this happen?\\n\"),\n    log(x)\n  )\n}\n\nf4(-1)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nHow did this happen?\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] NaN\n```\n\n\n:::\n:::\n\n\n## Exercise\n\n24. Explain the results of running the following code\n\n::: {.cell}\n\n```{.r .cell-code}\nshow_condition <- function(code) {\n  tryCatch(\n    error = function(cnd) \"error\",\n    warning = function(cnd) \"warning\",\n    message = function(cnd) \"message\",\n    {\n      code\n      5\n    }\n  )\n}\nshow_condition(stop(\"!\"))\nshow_condition(10)\nshow_condition(warning(\"?!\"))\n```\n:::\n\n## Activity\n\nWrite a function to take a single integer input and return:\n\n* `fizz` if the number is divisible by 5\n* `buzz` if the number is divisible by 7\n* `fizzbuzz` if the number is divisible by both 5 and 7\n* the number otherwise\n\nYour function should contain a `stop()` if the input is not an integer.\n\n## Assignment 1\n\\fontsize{12}{13.5}\\sf\n\nA supermarket has `p` checkouts and customers must choose one, forming a queue if it is already occupied. Customers always choose the shortest queue. The time between each new customer arriving at the checkouts has an exponential distribution with mean $\\mu$ minutes. The time it takes for a checkout operator to process a customer has an independent exponential distribution with mean $\\lambda$ minutes.\n\nWrite an R function to simulate the supermarket queues at each checkout, taking the arguments `mu`, `lambda`, `p` and `n`, and returning the total number of customers waiting to be served, `n` minutes after the supermarket opens. The argument `p` should have default value 3, while `n` should have default value `720` (the number of minutes in a 12 hour day). The other arguments should have no default values. Your function should be named `remaining_customers`.\n\nYour code should be as efficient as possible. Arguments should be checked for range and class.\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": null,
    "postProcess": false
  }
}