{
  "hash": "2c46f0edc55d5ad66f210a84b10fafac",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: ETC4500/ETC5450 Advanced&nbsp;R&nbsp;programming\nauthor: \"Week 1: R tools and data structures\"\nformat:\n  presentation-beamer:\n    fontsize: \"14pt,t\"\n    section-titles: false\n    toc: true\n    knitr:\n      opts_chunk:\n        dev: \"cairo_pdf\"\n    fig-width: 7.5\n    fig-height: 3.5\n    include-in-header: ../header.tex\n    keep-tex: false\n---\n\n\n\n# Unit admin\n\n## Introduction\n\n### Expectations\n\n* You know R and RStudio\n* You have a basic understanding of programming (for loops, if statements, functions)\n* You can use Git and GitHub (https://happygitwithr.com)\n\n\\pause\n\n### Unit resources\n\n* Everything on **https://arp.numbat.space**\n* Assignments submitted on GitHub Classroom\n* Discussion on Ed\n\n## Introduction\n\\fontsize{14}{15}\\sf\n\n### Assessment\n\n* Three group assignments building or fixing packages: 30% each\n* Individual discussion participation: 10%\n\n\\pause\n\n### GitHub\n\n* Use your `monash.edu` address.\n* Apply to GitHub Education as a student (<https://github.com/education/students>).\n* Gives you free access to private repos and GitHub Copilot.\n* Add GitHub Copilot to RStudio settings, or sign into GitHub in Positron.\n\n# The R language and tools\n\n## R history\n\n* S (1976, Chambers, Becker and Wilks; Bell Labs, USA)\n* S-PLUS (1988, Doug Martin; Uni of Washington, USA)\n* R (1993, Ihaka and Gentleman; Uni of Auckland, NZ)\n\n\\pause\\vspace*{0.4cm}\n\n### R influenced by\n\n* Lisp (functional programming, environments, dynamic typing)\n* Scheme (functional programming, lexical scoping)\n* S and S-PLUS (syntax)\n\n## Why R?\n\n* Free, open source, and on every major platform.\n* A diverse and welcoming community\n* A massive set of packages, often cutting-edge.\n* Powerful communication tools \\rlap{(Shiny, Rmarkdown, quarto)}\n* RStudio and Positron IDEs\n* Deep-seated language support for data analysis.\n* A strong foundation of functional programming.\n* Posit\n* Easy connection to high-performance programming languages like C, Fortran, and C++.\n\n## R challenges\n\n* R users are not usually programmers. Most R code by ordinary users is not very elegant, fast, or easy to understand.\n* R users more focused on results than good software practices.\n* R packages are inconsistent in design.\n* R can be slow.\n\n## RStudio and Positron\n\\fontsize{14}{15}\\sf\n\n* Integrated development environments (IDEs) for R.\n* Provide a user-friendly interface for writing and running R code, managing files, and visualising data.\n* RStudio is the most popular IDE for R, but Positron is a newer alternative that offers some additional features and is designed to also work with Python.\n* Choose one and set it up:\n\n  * GitHub integration\n  * A coding font with ligatures\n  * A theme you like\n  * Positron extensions\n\n## CRAN, Bioconductor, and GitHub\n\n* CRAN: Comprehensive R Archive Network, the official repository for R packages.\n* Bioconductor: a repository for R packages focused on bioinformatics.\n* GitHub: a platform for hosting and sharing code, including R packages.\n\n### Package installation\n\n`pak::pak()` is a modern package installer that resolves dependencies and installs packages from CRAN, Bioconductor, and GitHub.\n\n\n# Scalars and vectors\n\n## Scalars\n\n* **Logicals**: `TRUE` or `FALSE`, or abbreviated (`T` or `F`).\n\n* **Doubles**: decimal (`0.1234`), scientific (`1.23e4`), or hexadecimal (`0xcafe`). Special values: `Inf`, `-Inf`, and `NaN` (not a number).\n\n* **Integers**: `1234L`, `1e4L`, or `0xcafeL`. Can not contain fractional values.\n\n* **Strings**: `\"hi\"` or `'bye'`. Special characters are escaped with `\\`.\n\n## Making longer vectors with `c()` {#atomic-constructing}\n\nUse `c()` to create vectors.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlgl_var <- c(TRUE, FALSE)\nint_var <- c(1L, 6L, 10L)\ndbl_var <- c(1, 2.5, 4.5)\nchr_var <- c(\"these are\", \"some strings\")\n```\n:::\n\nWhen the inputs are atomic vectors, \\newline `c()` always flattens.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nc(c(1, 2), c(3, 4))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1 2 3 4\n```\n\n\n:::\n:::\n\n\n\\placefig{9.8}{2.5}{width=6cm}{../diagrams/vectors/atomic.png}\n\n## Atomic vectors\n\\vspace*{-0.2cm}\n\n* Four primary types of atomic vectors: `logical`, `double`, `integer`, and `character` (which contains strings).\n* Two rare types: `complex`, `raw`.\n* Collectively `integer` and `double` vectors are known as `numeric` vectors\n* `NULL` is like a zero length vector\n* Scalars are just vectors of length 1\n* Every vector can also have __attributes__: a named list of arbitrary metadata.\n* The __dimension__ attribute turns vectors into matrices and arrays.\n* The __class__ attribute powers the S3 object system.\n\n\n## Types and length\n\\fontsize{13}{13}\\sf\n\nYou can determine the type of a vector with `typeof()` and its length with `length()`.\n\n\\fontsize{10}{10}\\sf\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntypeof(lgl_var)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"logical\"\n```\n\n\n:::\n\n```{.r .cell-code}\ntypeof(int_var)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"integer\"\n```\n\n\n:::\n\n```{.r .cell-code}\ntypeof(dbl_var)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"double\"\n```\n\n\n:::\n\n```{.r .cell-code}\ntypeof(chr_var)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"character\"\n```\n\n\n:::\n:::\n\n\n## Missing values\n\nMost computations involving a missing value will return another missing value.\n\n\\fontsize{10}{10}\\sf\n\n\n::: {.cell}\n\n```{.r .cell-code}\nNA > 5\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] NA\n```\n\n\n:::\n\n```{.r .cell-code}\n10 * NA\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] NA\n```\n\n\n:::\n\n```{.r .cell-code}\n!NA\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] NA\n```\n\n\n:::\n:::\n\n\n## Missing values\n\nExceptions:\n\n\\fontsize{10}{10}\\sf\n\n\n::: {.cell}\n\n```{.r .cell-code}\nNA ^ 0\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1\n```\n\n\n:::\n\n```{.r .cell-code}\nNA | TRUE\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n\n```{.r .cell-code}\nNA & FALSE\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE\n```\n\n\n:::\n:::\n\n\n## Missing values\n\nUse `is.na()` to check for missingness\n\n\\fontsize{10}{10}\\sf\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- c(NA, 5, NA, 10)\nx == NA\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] NA NA NA NA\n```\n\n\n:::\n\n```{.r .cell-code}\nis.na(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  TRUE FALSE  TRUE FALSE\n```\n\n\n:::\n:::\n\n\n\\fontsize{13}{14}\\sf\n\nThere are actually four missing values: `NA` (logical), `NA_integer_` (integer), `NA_real_` (double), and `NA_character_` (character).\n\n## Coercion\n\\fontsize{13}{14}\\sf\\vspace*{-0.25cm}\n\n* For atomic vectors, all elements must be the same type.\n* When you combine different types they are __coerced__ in a fixed order: logical → integer → double → character.\n\n\\fontsize{10}{4}\\sf\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr(c(\"a\", 1))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n chr [1:2] \"a\" \"1\"\n```\n\n\n:::\n\n```{.r .cell-code}\nx <- c(FALSE, FALSE, TRUE)\nas.numeric(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0 0 1\n```\n\n\n:::\n\n```{.r .cell-code}\nsum(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1\n```\n\n\n:::\n\n```{.r .cell-code}\nas.integer(c(\"1\", \"1.5\", \"a\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  1  1 NA\n```\n\n\n:::\n:::\n\n\n## Exercises\n\n1.  Predict the output of the following:\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    c(1, FALSE)\n    c(\"a\", 1)\n    c(TRUE, 1L)\n    ```\n    :::\n\n\n2. Why is `1 == \"1\"` true? Why is `-1 < FALSE` true? Why is `\"one\" < 2` false?\n\n3. Why is the default missing value, `NA`, a logical vector? What's special\n   about logical vectors? (Hint: think about `c(FALSE, NA_character_)`.)\n\n## Getting and setting attributes\n\n* You can think of attributes as name-value pairs that attach metadata to an object.\n* Individual attributes can be retrieved and modified with `attr()`, or retrieved en masse with `attributes()`, and set en masse with `structure()`.\n\n\\fontsize{10}{10}\\sf\n\n\n::: {.cell}\n\n```{.r .cell-code}\na <- 1:3\nattr(a, \"x\") <- \"abcdef\"\na\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1 2 3\nattr(,\"x\")\n[1] \"abcdef\"\n```\n\n\n:::\n:::\n\n\n## Getting and setting attributes\n\\fontsize{10}{10}\\sf\n\n\n::: {.cell}\n\n```{.r .cell-code}\nattr(a, \"y\") <- 4:6\nstr(attributes(a))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nList of 2\n $ x: chr \"abcdef\"\n $ y: int [1:3] 4 5 6\n```\n\n\n:::\n\n```{.r .cell-code}\n# Or equivalently\na <- structure(\n  1:3,\n  x = \"abcdef\",\n  y = 4:6\n)\nstr(attributes(a))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nList of 2\n $ x: chr \"abcdef\"\n $ y: int [1:3] 4 5 6\n```\n\n\n:::\n:::\n\n\n\\placefig{10}{1}{width=3.5cm}{../diagrams/vectors/attr.png}\n\n## Names {#attr-names}\n\n* Names are a type of attribute.\n* You can name a vector in three ways:\n\n\\fontsize{10}{10}\\sf\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# When creating it:\nx <- c(a = 1, b = 2, c = 3)\n\n# By assigning a character vector to names()\nx <- 1:3\nnames(x) <- c(\"a\", \"b\", \"c\")\n\n# Inline, with setNames():\nx <- setNames(1:3, c(\"a\", \"b\", \"c\"))\n```\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\na b c \n1 2 3 \n```\n\n\n:::\n:::\n\n\n## Names\n\n* Avoid using `attr(x, \"names\")` as it requires more typing and is less readable than `names(x)`.\n* You can remove names from a vector by using\\newline `x <- unname(x)` or `names(x) <- NULL`.\n\n\n## Dimensions {#attr-dims}\n\n* Adding a `dim` attribute to a vector allows it to behave like a 2-dimensional __matrix__ or a multidimensional __array__.\n* You can create matrices and arrays with `matrix()` and `array()`, or by using the assignment form of `dim()`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Two scalar arguments specify row and column sizes\nx <- matrix(1:6, nrow = 2, ncol = 3)\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2] [,3]\n[1,]    1    3    5\n[2,]    2    4    6\n```\n\n\n:::\n:::\n\n\n## Dimensions\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# One vector argument to describe all dimensions\ny <- array(1:12, c(2, 3, 2))\ny\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n, , 1\n\n     [,1] [,2] [,3]\n[1,]    1    3    5\n[2,]    2    4    6\n\n, , 2\n\n     [,1] [,2] [,3]\n[1,]    7    9   11\n[2,]    8   10   12\n```\n\n\n:::\n:::\n\n\n## Dimensions\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# You can also modify an object in place by setting dim()\nz <- 1:6\ndim(z) <- c(3, 2)\nz\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2]\n[1,]    1    4\n[2,]    2    5\n[3,]    3    6\n```\n\n\n:::\n:::\n\n\n## Exercises\n\n4. What does `dim()` return when applied to a 1-dimensional vector?\n5. When might you use `NROW()` or `NCOL()`?\n6. How would you describe the following three objects? What makes them different from `1:5`?\n\n\n   ::: {.cell}\n   \n   ```{.r .cell-code}\n   x1 <- array(1:5, c(1, 1, 5))\n   x2 <- array(1:5, c(1, 5, 1))\n   x3 <- array(1:5, c(5, 1, 1))\n   ```\n   :::\n\n\n## S3 atomic vectors\n\n* `class` is a vector attribute.\n* It turns object into __S3 object__.\n* Four important S3 vectors:\n\n  * **factor** vectors.\n  * **Date** vectors with day resolution.\n  * **POSIXct** vectors for date-times.\n  * **difftime** vectors for durations.\n\n\\placefig{10}{2}{width=6cm}{../diagrams/vectors/summary-tree-s3-1.png}\n\n## Factors\n\n* A vector that can contain only predefined values.\n* Used to store categorical data.\n* Built on top of an integer vector with two attributes: a `class`, \"factor\", and `levels`, which defines the set of allowed values.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- factor(c(\"a\", \"b\", \"b\", \"a\"))\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] a b b a\nLevels: a b\n```\n\n\n:::\n:::\n\n\n## Factors\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntypeof(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"integer\"\n```\n\n\n:::\n\n```{.r .cell-code}\nattributes(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$levels\n[1] \"a\" \"b\"\n\n$class\n[1] \"factor\"\n```\n\n\n:::\n:::\n\n\n\\placefig{10}{2}{width=5cm}{../diagrams/vectors/factor.png}\n\n## Factors\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsex_char <- c(\"m\", \"m\", \"m\")\nsex_factor <- factor(sex_char, levels = c(\"m\", \"f\"))\n\ntable(sex_char)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nsex_char\nm \n3 \n```\n\n\n:::\n\n```{.r .cell-code}\ntable(sex_factor)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nsex_factor\nm f \n3 0 \n```\n\n\n:::\n:::\n\n\n## Factors\n\n* Be careful: some functions convert factors to integers!\n* ggplot preserves ordering of levels in graphs -- useful to reorder panels or legends.\n* Ordered factors are useful when the order of levels is meaningful.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngrade <- ordered(c(\"b\", \"b\", \"a\", \"c\"), levels = c(\"c\", \"b\", \"a\"))\ngrade\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] b b a c\nLevels: c < b < a\n```\n\n\n:::\n:::\n\n\n## Dates\n\n* Date vectors are built on top of double vectors.\n* Class \"Date\" with no other attributes:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntoday <- Sys.Date()\n\ntypeof(today)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"double\"\n```\n\n\n:::\n\n```{.r .cell-code}\nattributes(today)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$class\n[1] \"Date\"\n```\n\n\n:::\n:::\n\n\n## Dates\n\nThe value of the double (which can be seen by stripping the class), represents the number of days since 1970-01-01 (the \"Unix Epoch\").\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndate <- as.Date(\"1970-02-01\")\nunclass(date)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 31\n```\n\n\n:::\n:::\n\n\n## Date-times\n\n* Base R provides two ways of storing date-time information, POSIXct, and POSIXlt.\n* \"POSIX\" is short for Portable Operating System Interface\n* \"ct\" stands for calendar time; \"lt\" for local time\n* POSIXct vectors are built on top of double vectors, where the value represents the number of seconds since 1970-01-01.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnow_ct <- as.POSIXct(\"2018-08-01 22:00\", tz = \"UTC\")\nnow_ct\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"2018-08-01 22:00:00 UTC\"\n```\n\n\n:::\n\n```{.r .cell-code}\ntypeof(now_ct)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"double\"\n```\n\n\n:::\n\n```{.r .cell-code}\nattributes(now_ct)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$class\n[1] \"POSIXct\" \"POSIXt\" \n\n$tzone\n[1] \"UTC\"\n```\n\n\n:::\n:::\n\n\n## Date-times\n\nThe `tzone` attribute controls only how the date-time is formatted; it does not control the instant of time represented by the vector. Note that the time is not printed if it is midnight.\n\n\\fontsize{10}{10}\\sf\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstructure(now_ct, tzone = \"Asia/Tokyo\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"2018-08-02 07:00:00 JST\"\n```\n\n\n:::\n\n```{.r .cell-code}\nstructure(now_ct, tzone = \"America/New_York\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"2018-08-01 18:00:00 EDT\"\n```\n\n\n:::\n\n```{.r .cell-code}\nstructure(now_ct, tzone = \"Australia/Lord_Howe\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"2018-08-02 08:30:00 +1030\"\n```\n\n\n:::\n:::\n\n\n\n## Exercises\n\n7. What sort of object does `table()` return? What is its type? What\n    attributes does it have? How does the dimensionality change as you\n    tabulate more variables?\n\n8. What happens to a factor when you modify its levels?\n\n\n   ::: {.cell}\n   \n   ```{.r .cell-code}\n   f1 <- factor(letters)\n   levels(f1) <- rev(levels(f1))\n   ```\n   :::\n\n\n9. What does this code do? How do `f2` and `f3` differ from `f1`?\n\n\n   ::: {.cell}\n   \n   ```{.r .cell-code}\n   f2 <- rev(factor(letters))\n   f3 <- factor(letters, levels = rev(letters))\n   ```\n   :::\n\n\n# Lists and data frames\n## Lists\n\n* More complex than atomic vectors\n* Elements are *references* to objects of any type\n\n\\fontsize{10}{10}\\sf\n\n\n::: {.cell}\n\n```{.r .cell-code}\nl1 <- list(\n  1:3, \"a\", c(TRUE, FALSE, TRUE), c(2.3, 5.9)\n)\ntypeof(l1)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"list\"\n```\n\n\n:::\n\n```{.r .cell-code}\nstr(l1)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nList of 4\n $ : int [1:3] 1 2 3\n $ : chr \"a\"\n $ : logi [1:3] TRUE FALSE TRUE\n $ : num [1:2] 2.3 5.9\n```\n\n\n:::\n:::\n\n\n\\placefig{10}{3.5}{width=5cm}{../diagrams/vectors/list.png}\n\n## Lists\n\n* Lists can be recursive: a list can contain other lists.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nl3 <- list(list(list(1)))\nstr(l3)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nList of 1\n $ :List of 1\n  ..$ :List of 1\n  .. ..$ : num 1\n```\n\n\n:::\n:::\n\n\n\\placefig{10}{4}{width=5cm}{../diagrams/vectors/list-recursive.png}\n\n## Lists\n\n* `c()` will combine several lists into one.\n\n\\fontsize{9}{9}\\sf\n\n\n::: {.cell}\n\n```{.r .cell-code}\nl4 <- list(list(1, 2), c(3, 4))\nl5 <- c(list(1, 2), c(3, 4))\nstr(l4)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nList of 2\n $ :List of 2\n  ..$ : num 1\n  ..$ : num 2\n $ : num [1:2] 3 4\n```\n\n\n:::\n\n```{.r .cell-code}\nstr(l5)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nList of 4\n $ : num 1\n $ : num 2\n $ : num 3\n $ : num 4\n```\n\n\n:::\n:::\n\n\n\\placefig{10}{3}{width=5cm}{../diagrams/vectors/list-c.png}\n\n## Testing and coercion {#list-types}\n\n\\fontsize{9}{9}\\sf\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlist(1:3)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[[1]]\n[1] 1 2 3\n```\n\n\n:::\n\n```{.r .cell-code}\nas.list(1:3)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[[1]]\n[1] 1\n\n[[2]]\n[1] 2\n\n[[3]]\n[1] 3\n```\n\n\n:::\n:::\n\n\n\\fontsize{13}{14}\\sf\n\n* You can turn a list into an atomic vector with `unlist()`.\n\n## Data frames and tibbles {#tibble}\n\\vspace*{-0.2cm}\n\\placefig{12.2}{0.35}{width=3cm}{../diagrams/vectors/summary-tree-s3-2.png}\n\n* Most important S3 vectors built on lists:\\newline data frames and tibbles.\n\n\\fontsize{10}{8}\\sf\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf1 <- data.frame(x = 1:3, y = letters[1:3])\ntypeof(df1)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"list\"\n```\n\n\n:::\n\n```{.r .cell-code}\nattributes(df1)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$names\n[1] \"x\" \"y\"\n\n$class\n[1] \"data.frame\"\n\n$row.names\n[1] 1 2 3\n```\n\n\n:::\n:::\n\n\n\n\\placefig{5.5}{5.5}{width=2.5cm}{../diagrams/vectors/data-frame-2.png}\n\n\n## Data frames and tibbles\n\n* A data frame has a constraint: the length of each of its vectors must be the same.\n* A data frame has `rownames()` and `colnames()`. The `names()`\n  of a data frame are the column names.\n* A data frame has `nrow()` rows and `ncol()` columns. The `length()` of a\n  data frame gives the number of columns.\n\n## tibbles\n\\fontsize{13}{14}\\sf\n\n* Modern reimagining of the data frame.\n* tibbles are \"lazy and surly\": they do less and complain more.\n\n\\fontsize{10}{8}\\sf\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tibble)\ndf2 <- tibble(x = 1:3, y = letters[1:3])\ntypeof(df2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"list\"\n```\n\n\n:::\n\n```{.r .cell-code}\nattributes(df2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$class\n[1] \"tbl_df\"     \"tbl\"        \"data.frame\"\n\n$row.names\n[1] 1 2 3\n\n$names\n[1] \"x\" \"y\"\n```\n\n\n:::\n:::\n\n\n\n## Creating data frames and tibbles\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnames(data.frame(`1` = 1))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"X1\"\n```\n\n\n:::\n\n```{.r .cell-code}\nnames(tibble(`1` = 1))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"1\"\n```\n\n\n:::\n:::\n\n\n## Creating data frames and tibbles\n\n\\fontsize{10}{10}\\sf\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata.frame(x = 1:4, y = 1:2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  x y\n1 1 1\n2 2 2\n3 3 1\n4 4 2\n```\n\n\n:::\n\n```{.r .cell-code}\ntibble(x = 1:4, y = 1:2)\n```\n\n::: {.cell-output .cell-output-error}\n\n```\nError in `tibble()`:\n! Tibble columns must have compatible sizes.\n* Size 4: Existing data.\n* Size 2: Column `y`.\ni Only values of size one are recycled.\n```\n\n\n:::\n:::\n\n\n## Creating data frames and tibbles\n\\fontsize{10}{10}\\sf\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntibble(\n  x = 1:3,\n  y = x * 2,\n  z = 5\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3 x 3\n      x     y     z\n  <int> <dbl> <dbl>\n1     1     2     5\n2     2     4     5\n3     3     6     5\n```\n\n\n:::\n:::\n\n\n\n## Row names {#rownames}\n\nData frames allow you to label each row with a name, a character vector containing only unique values:\n\n\\fontsize{10}{10}\\sf\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf3 <- data.frame(\n  age = c(35, 27, 18),\n  hair = c(\"blond\", \"brown\", \"black\"),\n  row.names = c(\"Bob\", \"Susan\", \"Sam\")\n)\ndf3\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n      age  hair\nBob    35 blond\nSusan  27 brown\nSam    18 black\n```\n\n\n:::\n:::\n\n\n## Row names\n\n* tibbles do not support row names\n* convert row names into a regular column with either `rownames_to_column()`, or the `rownames` argument:\n\n\\fontsize{10}{10}\\sf\n\n\n::: {.cell}\n\n```{.r .cell-code}\nas_tibble(df3, rownames = \"name\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3 x 3\n  name    age hair \n  <chr> <dbl> <chr>\n1 Bob      35 blond\n2 Susan    27 brown\n3 Sam      18 black\n```\n\n\n:::\n:::\n\n\n## Printing\n\n\\fontsize{10}{9.5}\\sf\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndplyr::starwars\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 87 x 14\n   name       height  mass hair_color skin_color eye_color birth_year sex  \n   <chr>       <int> <dbl> <chr>      <chr>      <chr>          <dbl> <chr>\n 1 Luke Skyw~    172    77 blond      fair       blue            19   male \n 2 C-3PO         167    75 <NA>       gold       yellow         112   none \n 3 R2-D2          96    32 <NA>       white, bl~ red             33   none \n 4 Darth Vad~    202   136 none       white      yellow          41.9 male \n 5 Leia Orga~    150    49 brown      light      brown           19   fema~\n 6 Owen Lars     178   120 brown, gr~ light      blue            52   male \n 7 Beru Whit~    165    75 brown      light      blue            47   fema~\n 8 R5-D4          97    32 <NA>       white, red red             NA   none \n 9 Biggs Dar~    183    84 black      light      brown           24   male \n10 Obi-Wan K~    182    77 auburn, w~ fair       blue-gray       57   male \n# i 77 more rows\n# i 6 more variables: gender <chr>, homeworld <chr>, species <chr>,\n#   films <list>, vehicles <list>, starships <list>\n```\n\n\n:::\n:::\n\n\n## Printing\n\n* tibbles only show first 10 rows and all columns that fit on\n  screen. Additional columns shown at bottom.\n* Each column labelled with its type, abbreviated to 3--4 letters.\n* Wide columns truncated.\n\n## List columns\n\n\\fontsize{10}{10}\\sf\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf <- data.frame(x = 1:3)\ndf$y <- list(1:2, 1:3, 1:4)\ndf\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  x          y\n1 1       1, 2\n2 2    1, 2, 3\n3 3 1, 2, 3, 4\n```\n\n\n:::\n:::\n\n\n\\placefig{10}{1.5}{width=5cm}{../diagrams/vectors/data-frame-list.png}\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntibble(\n  x = 1:3,\n  y = list(1:2, 1:3, 1:4)\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3 x 2\n      x y        \n  <int> <list>   \n1     1 <int [2]>\n2     2 <int [3]>\n3     3 <int [4]>\n```\n\n\n:::\n:::\n\n\n## Matrix and data frame columns\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndfm <- tibble(\n  x = 1:3 * 10,\n  y = matrix(1:9, nrow = 3),\n  z = data.frame(a = 3:1, b = letters[1:3])\n)\nstr(dfm)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\ntibble [3 x 3] (S3: tbl_df/tbl/data.frame)\n $ x: num [1:3] 10 20 30\n $ y: int [1:3, 1:3] 1 2 3 4 5 6 7 8 9\n $ z:'data.frame':\t3 obs. of  2 variables:\n  ..$ a: int [1:3] 3 2 1\n  ..$ b: chr [1:3] \"a\" \"b\" \"c\"\n```\n\n\n:::\n:::\n\n\n\\placefig{10}{1.25}{width=5cm}{../diagrams/vectors/data-frame-matrix.png}\n\n## Exercises\n\n10.  What happens if you attempt to set `rownames` that are not unique?\n11.  If `df` is a data frame, what can you say about `t(df)`, and `t(t(df))`?\n    Perform some experiments, making sure to try different column types.\n12.  What does `as.matrix()` do when applied to a data frame with\n    columns of different types? How does it differ from `data.matrix()`?\n\n## `NULL`\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlength(NULL)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0\n```\n\n\n:::\n:::\n\n\nYou can test for `NULL`s with `is.null()`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- NULL\nx == NULL\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nlogical(0)\n```\n\n\n:::\n\n```{.r .cell-code}\nis.null(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n:::\n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": null,
    "postProcess": false
  }
}