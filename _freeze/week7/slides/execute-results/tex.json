{
  "hash": "82639a1465e001bb214989eee4ee2a72",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: ETC4500/ETC5450 Advanced&nbsp;R&nbsp;programming\nauthor: \"Week 7: Reactive programming with targets and renv\"\nformat:\n  presentation-beamer:\n    fontsize: \"14pt,t\"\n    section-titles: false\n    knitr:\n      opts_chunk:\n        dev: \"cairo_pdf\"\n    fig-width: 7.5\n    fig-height: 3.5\n    include-in-header: ../header.tex\n    colorlinks: true\n    urlcolor: MonashBlue\n    linkcolor: burntorange\n---\n\n\n\n# Reactive programming\n\n## Regular (imperative) programming\n\nConsider how code is usually evaluated...\n\n\n::: {.cell}\n\n```{.r .cell-code}\na <- 1\nb <- 2\nx <- a + b\nx\n```\n:::\n\n\nWhat is `x`?\n\n\n::: {.cell}\n\n```{.r .cell-code}\na <- -1\nx\n```\n:::\n\n\nWhat is `x` now?\n\n## Regular (imperative) programming\n\n::: {.callout-tip title=\"Predictable programming\"}\nAll programming we've seen so far evaluates code in sequential order, line by line.\n\n\\hspace{1em}\n\nSince `x` was not re-evaluated, its value stays the same even when its inputs have changed.\n:::\n\n<!-- . . . -->\n\n<!-- *Note: this is why it's especially important to ensure code works when ran from top to bottom, since when doing a data analysis we often write and run code more freely!* -->\n\n## Reactive programming\n\nWithin a reactive programming paradigm, objects *react* to changes in their inputs and automatically update their value!\n\n. . .\n\n::: {.callout-warning title=\"Disclaimer\"}\nReactive programming is a broad and diverse paradigm, we'll focus only on the basic concepts and how they apply in shiny applications.\n:::\n\n## Reactive programming\n\nWe can implement *reactivity* with functions & environments.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(rlang)\nreact <- function(e) new_function(alist(), expr(eval(!!enexpr(e))))\n```\n:::\n\n\nWe'll learn how this function works later (metaprogramming).\n\nReactive programming is also smarter about *'invalidation'*, results are **cached and reused** if the inputs aren't changed.\n\n## Reactive programming\n\nHow does reactive programming differ?\n\n\n::: {.cell}\n\n```{.r .cell-code}\na <- 1\nb <- 2\ny <- react(a + b)\ny()\n```\n:::\n\n\nWhat is `y`?\n\n\n::: {.cell}\n\n```{.r .cell-code}\na <- -1\ny()\n```\n:::\n\n\nWhat is `y` now?\n\n## Reactive programming\n\n::: {.callout-tip title=\"(Un)predictable programming?\"}\nReactive programming can be disorienting!\n\n\\hspace{1em}\n\nReactive objects *invalidate* whenever their inputs change, and so its value will be recalculated and stay up-to-date.\n:::\n\n## Reactive programming\n\n::: {.callout-caution title=\"Your turn!\"}\n<!-- Experiment with using `react()` in R. -->\n\n<!-- ```{r} -->\n<!-- library(rlang) -->\n<!-- react <- function(e) new_function(alist(), expr(eval(!!enexpr(e)))) -->\n<!-- ``` -->\n\n\n::: {.cell}\n\n```{.r .cell-code}\na <- 1\nb <- 2\ny <- react(a + b)\ny()\n```\n:::\n\n\nWhen was `a + b` evaluated?\n\n\\vspace{1em}\n\nHow does this differ from ordinary (imperative) code?\n:::\n\n## Imperative and declarative programming\n\n\\fontsize{13}{13}\\sf\n::: {.callout-note icon=false title=\"Imperative programming\"}\n* Specific commands are carried out immediately.\n* Usually direct and exact instructions.\n* e.g. read in data from this file.\n:::\n\n::: {.callout-note icon=false title=\"Declarative programming\"}\n* Specific commands are carried out when needed.\n* Expresses higher order goals / constraints.\n* e.g. make sure this dataset is up to date every time I see it.\n:::\n\n## Use cases for reactive programming\n\n\\fontsize{13}{13}\\sf\n::: {.callout-important title=\"Use-less cases\"}\nThis paradigm is rarely needed or used in R for data analysis.\n:::\n\n::: {.callout-tip title=\"Useful cases\"}\nReactive programming is useful for developing user applications (including web apps!).\n\n\\vspace{1em}\n\nIn R, the shiny package uses reactive programming for writing app interactivity.\n:::\n\n# Caching\n\n## Caching: using rds\n\n\n::: {.cell}\n\n```{.r .cell-code}\nif (file.exists(\"results.rds\")) {\n  res <- readRDS(\"results.rds\")\n} else {\n  res <- compute_it() # a time-consuming function\n  saveRDS(res, \"results.rds\")\n}\n```\n:::\n\n\n\\pause\\vspace*{1cm}\n\n\\alert{Equivalently\\dots}\n\n\n::: {.cell}\n\n```{.r .cell-code}\nres <- xfun::cache_rds(\n  compute_it(), # a time-consuming function\n  file = \"results.rds\"\n)\n```\n:::\n\n\n## Caching: using rds\n\\fontsize{10}{10}\\sf\n\n\n::: {.cell freeze='false'}\n\n```{.r .cell-code}\ncompute <- function(...) {\n  xfun::cache_rds(rnorm(6), file = \"results.rds\", ...)\n}\ncompute()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] -1.547 -0.211 -2.169  0.381 -1.565  0.683\n```\n\n\n:::\n\n```{.r .cell-code}\ncompute()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] -1.547 -0.211 -2.169  0.381 -1.565  0.683\n```\n\n\n:::\n:::\n\n\n\n\n\n::: {.cell freeze='false'}\n\n```{.r .cell-code}\ncompute(rerun = TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  1.797 -1.495 -0.976 -0.898 -1.664  0.705\n```\n\n\n:::\n\n```{.r .cell-code}\ncompute()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  1.797 -1.495 -0.976 -0.898 -1.664  0.705\n```\n\n\n:::\n:::\n\n\n## Caching downloads\n\nYou often want to prevent downloads of the same data multiple times.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndownload_data <- function(url) {\n  dest_folder <- tempdir()\n  sanitized_url <- stringr::str_replace_all(url, \"/\", \"_\")\n  dest_file <- file.path(dest_folder, paste0(sanitized_url, \".rds\"))\n  if (file.exists(dest_file)) {\n    data <- readRDS(dest_file)\n  } else {\n    data <- read_tsv(url, show_col_types = FALSE)\n    saveRDS(data, dest_file)\n  }\n  data\n}\nbulldozers <- download_data(\"https://robjhyndman.com/data/Bulldozers.csv\")\n```\n:::\n\n\n## Caching: memoise\n\nCaching stores results of computations so they can be reused.\n\n\\fontsize{10}{10}\\sf\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(memoise)\nsq <- function(x) {\n  print(\"Computing square of 'x'\")\n  x**2\n}\nmemo_sq <- memoise(sq)\nmemo_sq(2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Computing square of 'x'\"\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 4\n```\n\n\n:::\n\n```{.r .cell-code}\nmemo_sq(2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 4\n```\n\n\n:::\n:::\n\n\n## Caching: Rmarkdown\n\n\n````{.default}\n```{r import-data, cache=TRUE}\nd <- read.csv('my-precious.csv')\n```\n\n```{r analysis, dependson='import-data', cache=TRUE}\nsummary(d)\n```\n````\n\n* Requires explicit dependencies or changes not detected.\n* Changes to functions or packages not detected.\n* Good practice to frequently clear cache to avoid problems.\n* targets is a better solution\n\n## Caching: Quarto\n\n\n````{.default}\n```{r}\n#| label: import-data\n#| cache: true\nd <- read.csv('my-precious.csv')\n```\n\n```{r}\n#| label: analysis\n#| dependson: import-data\n#| cache: true\nsummary(d)\n```\n````\n\n* Same problems as Rmarkdown\n* targets is a better solution\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": null,
    "postProcess": false
  }
}