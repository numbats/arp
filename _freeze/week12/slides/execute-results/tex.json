{
  "hash": "a8626b65b1ecb3a255d3ef7f6efda66d",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: ETC4500/ETC5450 Advanced&nbsp;R&nbsp;programming\nauthor: \"Week 12: Interfacing with other languages\"\nformat:\n  presentation-beamer:\n    fontsize: \"14pt,t\"\n    section-titles: false\n    knitr:\n      opts_chunk:\n        dev: \"cairo_pdf\"\n    fig-width: 7.5\n    fig-height: 3.5\n    include-in-header: ../header.tex\n    keep-tex: false\n---\n\n\n\n## Outline\n\n\\vspace*{0.4cm}\n\\tableofcontents\n\n\n# Unit updates\n\n## SETUs\n\n**SETUs are now open.**\n\nPlease complete your SETU, we make improvements based on your feedback.\n\nThis is especially important for us in this unit, since it is our first year running the unit!\n\n<https://monash.edu/ups/setu>\n\n# R as an interface language\n\n## R as an interface language\n\nR is a powerful design language, with lots of flexibility for creating good (or bad) programming interfaces.\n\nMuch of R is built up on libraries from other languages, and R's flexible interface design makes them easy to use.\n\n<!-- :::{callout-tip title = \"Interface packages\"} -->\n<!-- We can write packages that interface libraries from other packages -->\n<!-- ::: -->\n\n## R Core\n\nR itself is mostly written using different programming languages (mostly C and Fortran).\n\nYou can find the source code for R at <https://svn.r-project.org/R/>, or mirrored on GitHub at <https://github.com/wch/r-source>\n\n## Wrapper functions and abstractions\n\nThe use of abstraction and wrapping other software is fundamental to programming.\n\nWrapper functions call a second function with minimal/no change to the output. They are used to adapt existing code to work for a new design or programming language.\n\nWrappers often involve abstraction, a process of reducing complexity by simplifying the user-facing function's design.\n\n\n## Wrapping functions with NSE\n\nLast week we saw how non-standard evaluation (NSE) can take any syntactically valid R code and evaluate it differently.\n\nMetaprogramming is often used to directly translate R code into other languages.\n\n# Interfacing other programming languages\n\n## Interfacing other programming languages\n\nAn interface to a different programming language involves:\n\n* Designing an R interface which can be translated into code for the other language\n* Converting objects to and from each language\n* Passing side-effects (like image output)\n\n## Interfacing Python with reticulate\n\n\\placefig{13.5}{0.5}{width=2cm}{../screenshots/reticulate.png}\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(reticulate)\n```\n:::\n\nThe `reticulate` package allows Python to run from within R.\n\n* Translates R syntax to Python\n* Converts R objects to Python\n* Converts Python objects to R\n\nThe Python version and package environment can be set with:\n\n::: {.cell}\n\n```{.r .cell-code}\nuse_python(\"/usr/local/bin/python\")\n```\n:::\n\n## Python example from R with reticulate\n\n\\fontsize{10}{10}\\sf\n::: {.cell}\n\n```{.r .cell-code}\n# reticulate::py_install(\"numpy\")\nnp <- import(\"numpy\", convert = FALSE)\n\n# do some array manipulations with NumPy\na <- np$array(c(1:4))\na\n```\n:::\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\n[1, 2, 3, 4]\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nsum <- a$cumsum()\nsum\n```\n:::\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\n[1, 3, 6, 10]\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# convert to R explicitly at the end\npy_to_r(sum)\n```\n:::\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  1  3  6 10\n```\n\n\n:::\n:::\n\n\n## Converting objects between R and Python\n\nFull conversion table here: [*Calling Python*](https://rstudio.github.io/reticulate/articles/calling_python.html#type-conversions)\n\n\\fontsize{10}{10}\\sf\n::: {.cell}\n\n```{.r .cell-code}\nr_to_py(1)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n1.0\n```\n\n\n:::\n\n```{.r .cell-code}\nr_to_py(1:10)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n```\n\n\n:::\n\n```{.r .cell-code}\nr_to_py(list(norm = rnorm(10), pois = rpois(10, 3)))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n{'norm': [0.9010646983623329, 0.8461974860995545, 0.7198654763350233, -0.015168553960483671, -0.7840887932374172, 1.03355423831251, 1.5582524359170502, -1.1691518331364288, 0.673226426484983, 0.10757530669893382], 'pois': [6, 4, 1, 4, 2, 6, 0, 4, 3, 4]}\n```\n\n\n:::\n\n```{.r .cell-code}\nr_to_py(mtcars)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nDict (11 items)\n```\n\n\n:::\n:::\n\n## Plots (and other side-effects)\n\n\\fontsize{10}{10}\\sf\n::: {.cell}\n\n```{.r .cell-code}\nplt <- import(\"matplotlib.pyplot\")\nfig <- plt$figure(figsize=c(14,8))\nx <- seq(-3, 3, by = 0.01)\nplt$plot(x,dnorm(x))\nplt$show()\n```\n:::\n\n![](pyplot.png){height=50%}\n\n\n## Interfacing other programming languages\n\n* Any system commands with `system()`\n* C/C++: Directly in R with `.Call()` or Rcpp (next week!)\n* Julia: JuliaCall\n* Matlab/Octave: R.matlab\n* Stata: RStata\n* JavaScript: V8\n* Java: rJava\n* Lua: luajr\n\n# Data analysis with databases\n\n## Data analysis with databases\n\nOften data for analysis is stored and used within a database.\n\nA database is an efficient way of securely storing and interacting with large datasets.\n\nIt is also a good technique for working with data that is too large to fit in memory.\n\n## dbplyr\n\n\\placefig{13.5}{0.5}{width=2cm}{../screenshots/dbplyr.png}\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(dbplyr)\n```\n:::\n\n\nThe dbplyr package allows you to use dplyr code to manipulate tables from databases.\n\nIt achieves this using non-standard evaluation to convert dplyr and R code into suitable database code for a connected database.\n\n## dbplyr backends\n\nBackends are interfaces between R and database languages.\n\nThere are many database backends available for dbplyr:\n\n:::: {.columns}\n\n::: {.column width=\"50%\"}\n* MySQL / SQLite\n* Snowflake\n* PostgreSQL\n* Spark\n* ODBC\n* MS Access\n:::\n\n::: {.column width=\"50%\"}\n* SAP HANA\n* Hive\n* Impala\n* Oracle\n* Redshift\n* Teradata\n:::\n\n::::\n\n## Creating a database\n\nYou can quickly create a SQLite database in memory with:\n\n::: {.cell}\n\n```{.r .cell-code}\ncon <- DBI::dbConnect(RSQLite::SQLite(), \":memory:\")\ncon\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n<SQLiteConnection>\n  Path: :memory:\n  Extensions: TRUE\n```\n\n\n:::\n:::\n\nCurrently this database doesn't contain any tables:\n\n::: {.cell}\n\n```{.r .cell-code}\nDBI::dbListTables(con)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\ncharacter(0)\n```\n\n\n:::\n:::\n\n## Using a database\n\nWe can add a dataset to the database from R with:\n\n\\fontsize{10}{10}\\sf\n::: {.cell}\n\n```{.r .cell-code}\ncopy_to(con, mtcars)\nDBI::dbListTables(con)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"mtcars\"       \"sqlite_stat1\" \"sqlite_stat4\"\n```\n\n\n:::\n:::\n\n\\fontsize{14}{10}\\sf\nYou can then retrieve the table using `tbl()`\n\n\\fontsize{10}{10}\\sf\n::: {.cell}\n\n```{.r .cell-code}\ntbl(con, \"mtcars\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# Source:   table<`mtcars`> [?? x 11]\n# Database: sqlite 3.47.1 [:memory:]\n     mpg   cyl  disp    hp  drat    wt  qsec    vs    am  gear  carb\n   <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl>\n 1  21       6  160    110  3.9   2.62  16.5     0     1     4     4\n 2  21       6  160    110  3.9   2.88  17.0     0     1     4     4\n 3  22.8     4  108     93  3.85  2.32  18.6     1     1     4     1\n 4  21.4     6  258    110  3.08  3.22  19.4     1     0     3     1\n 5  18.7     8  360    175  3.15  3.44  17.0     0     0     3     2\n 6  18.1     6  225    105  2.76  3.46  20.2     1     0     3     1\n 7  14.3     8  360    245  3.21  3.57  15.8     0     0     3     4\n 8  24.4     4  147.    62  3.69  3.19  20       1     0     4     2\n 9  22.8     4  141.    95  3.92  3.15  22.9     1     0     4     2\n10  19.2     6  168.   123  3.92  3.44  18.3     1     0     4     4\n# i more rows\n```\n\n\n:::\n:::\n\n## Manipulating a table\n\nWith the database table object, you can use dplyr:\n\n\\fontsize{10}{10}\\sf\n::: {.cell}\n\n```{.r .cell-code}\ntbl(con, \"mtcars\") |>\n  group_by(cyl) |>\n  summarise(mean(mpg), mean(hp))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# Source:   SQL [?? x 3]\n# Database: sqlite 3.47.1 [:memory:]\n    cyl `mean(mpg)` `mean(hp)`\n  <dbl>       <dbl>      <dbl>\n1     4        26.7       82.6\n2     6        19.7      122. \n3     8        15.1      209. \n```\n\n\n:::\n:::\n\n## Collecting the results\n\nWhen your dplyr data manipulation is complete, you can then `collect()` your results as a regular R data frame for use with other packages.\n\n\\fontsize{10}{10}\\sf\n::: {.cell}\n\n```{.r .cell-code}\ntbl(con, \"mtcars\") |>\n  group_by(cyl) |>\n  summarise(mean(mpg), mean(hp)) |>\n  collect()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3 x 3\n    cyl `mean(mpg)` `mean(hp)`\n  <dbl>       <dbl>      <dbl>\n1     4        26.7       82.6\n2     6        19.7      122. \n3     8        15.1      209. \n```\n\n\n:::\n:::\n\n## Disconnecting from a database\n\nOnce finished, it is good practice to disconnect from the database using `DBI::dbDisconnect()`:\n\n::: {.cell}\n\n```{.r .cell-code}\nDBI::dbDisconnect(con)\n```\n:::\n\nSee now that the database is disconnected:\n\n::: {.cell}\n\n```{.r .cell-code}\ncon\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n<SQLiteConnection>\n  DISCONNECTED\n```\n\n\n:::\n:::\n\n\n## Connecting to a remote database\n\nIn most cases you will be connecting to a remove database.\n\nHere's the credentials to a PostgreSQL database containing some very important data:\n\n* Host: arp.nectric.com.au:5432\n* Username: monash\n* Password: arp2024\n* Database: arp\n\n## Connecting to a remote database\n\n::: {.callout-caution title=\"Your turn!\"}\nConnect to the remote database and use the data.\n\n\\vspace{1em}\n\nHint: the connection code looks like this:\n\n::: {.cell}\n\n```{.r .cell-code}\ncon <- DBI::dbConnect(\n  RPostgres::Postgres(),\n  dbname = \"???\",\n  host = \"???\", port = \"???\",\n  user = \"???\", password = \"???\"\n)\n```\n:::\n\n\n\n:::\n\n\n## Using data on a remote database\n\nAs before, dbplyr allows you to manipulate tables using dplyr code.\n\n\\fontsize{10}{10}\\sf\n::: {.cell}\n\n```{.r .cell-code}\ntbl(con, \"penguins\") |>\n  group_by(species) |>\n  summarise(avg_mass_g = mean(body_mass_g, na.rm = TRUE))\n```\n:::\n\n\\fontsize{14}{10}\\sf\nAll database operations are done on the remote server.\n\n## How it works - translating expressions\n\ndbplyr uses NSE to translate R code into SQL / database code.\n\nYou can try this out directly with `translate_sql()`:\n\n\\fontsize{10}{10}\\sf\n::: {.cell}\n\n```{.r .cell-code}\ntranslate_sql(mean(body_mass_g, na.rm = TRUE), con = con)\ntranslate_sql(x ^ 2L, con = con)\ntranslate_sql(substr(x, 5, 10), con = con)\n```\n:::\n\n## How it works - translating expressions\n\nNot all R functions can be translated to database queries.\n\nConsider `logp1()`, it gets translated directly as SQL:\n\n\\fontsize{10}{10}\\sf\n::: {.cell}\n\n```{.r .cell-code}\ntranslate_sql(logp1(x), con = con)\n```\n:::\n\n\\fontsize{14}{10}\\sf\nHowever this doesn't work, `log(body_mass_g + 1)` does.\n\n\\fontsize{10}{10}\\sf\n::: {.cell}\n\n```{.r .cell-code}\ntbl(con, \"penguins\") |>\n  mutate(logp1(body_mass_g))\n```\n:::\n\n\n## How it works - translating expressions\n\nNot all database queries can be written in R.\n\nFor this you can write literal `SQL` commands with the `sql()` function.\n\n\\fontsize{10}{10}\\sf\n::: {.cell}\n\n```{.r .cell-code}\ntranslate_sql(sql(\"x!\"), con = con)\ntranslate_sql(x == sql(\"ANY VALUES(1, 2, 3)\"), con = con)\n```\n:::\n\n\n## How it works - translating dplyr verbs\n\nFor any chain of dplyr commands, you can find the SQL / database query by using `show_query()` instead of `collect()`.\n\n::: {.cell}\n\n```{.r .cell-code}\ntbl(con, \"penguins\") |>\n  group_by(species) |>\n  summarise(avg_mass_g = mean(body_mass_g, na.rm = TRUE)) |>\n  show_query()\n```\n:::\n\n# Creating interactive web components\n\n## Creating interactive web components\n\nIn week 8 we saw how reactive programming can add interactivity to web applications using shiny.\n\nToday we'll see how to use R and Javascript to create interactive UI elements.\n\n:::{.callout-tip title=\"Concepts combined\"}\n\nThe UI elements from today and the reactive server code from week 8 is all the ingredients to create shiny apps.\n\n:::\n\n## Shiny extensions\n\nThere are many JS libraries which have been wrapped up into R packages, for use in Shiny or regular analysis.\n\n<https://github.com/nanxstats/awesome-shiny-extensions>\n\n## htmltools\n\n\\placefig{13.5}{0.5}{width=2cm}{../screenshots/htmltools.png}\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(htmltools)\n```\n:::\n\nThe htmltools package allows you to write HTML code with R.\n\n::: {.cell}\n\n```{.r .cell-code}\ndiv(\n  p(\"Hello world!\"),\n  img(src = \"earth.jpg\")\n)\n```\n\n::: {.cell-output-display}\n\n```{=html}\n<div>\n<p>Hello world!</p>\n<img src=\"earth.jpg\"/>\n</div>\n```\n\n:::\n:::\n\n:::: {.columns}\n\n::: {.column width=\"50%\"}\n```html\n<div>\n  <p>Hello world!</p>\n  <img src=\"earth.jpg\"/>\n</div>\n```\n\n:::\n\n::: {.column width=\"50%\"}\nHello world!\n\n![](earth.jpg){width=\"50%\"}\n:::\n\n::::\n\n## htmltools\n\nThis is used to create the UI of a Shiny app.\n\nIt is also include the necessary CSS/JS dependencies for HTML reports with interactive 'widgets'.\n\n## htmlwidgets\n\nThe htmlwidgets package provides a framework for creating R bindings to JavaScript libraries. HTML Widgets can be:\n\n* Used at the R console for data analysis just like conventional R plots.\n* Embedded within R Markdown documents\n* Incorporated into Shiny web applications.\n* Saved as standalone web pages for ad-hoc sharing via email, file transfer, web deployment, etc.\n\n## htmlwidgets showcase\n\nThe htmlwidgets package powers many popular R packages including:\n\n* leaflet\n* plotly\n* visNetwork\n* DiagrammeR\n\n<http://www.htmlwidgets.org/>\n\n## htmlwidgets components\n\nAll widgets include the following components:\n\n* Web dependencies: JS and CSS assets used by the widget\n* R binding: This is the function that users call to create the output\n* JavaScript binding: The JavaScript code that glues everything together, passing data/options from the R binding to the underlying JavaScript library.\n\n## htmlwidgets setup\n\nFrom within a package, you can quickly get started with a htmlwidget using:\n\n```r\nhtmlwidgets::scaffoldWidget(\"mywidget\")\n```\n\n::: {.callout-caution title=\"Follow along!\"}\n\nCreate a package for making interactive wordclouds.\n\nWe'll use the wordcloud2.js library, available on GitHub here: <https://github.com/timdream/wordcloud2.js>\n:::\n\n\n## htmlwidgets setup\n\nThe htmlwidgets components are organised in packages with this file structure:\n\n\\fontsize{10}{10}\\sf\n```\nR/\n| <name>.R\n\ninst/\n|-- htmlwidgets/\n|   |-- <name>.js\n|   |-- <name>.yaml\n|   |-- lib/\n|   |   |-- <javascript library>/\n```\n\n## Web dependencies\n\nDependencies are specified using the YAML configuration file located at `inst/htmlwidgets/<name>.yaml`.\n\n```yaml\ndependencies:\n  - name: <name>\n    version: <version>\n    src: htmlwidgets/lib/<src>\n    script:\n      - <JS files>\n    stylesheet:\n      - <CSS files>\n```\n\n## Web dependencies\n\n::: {.callout-caution title=\"Follow along!\"}\nDownload the JavaScript src for wordcloud2.js and add it to the package as a htmlwidgets dependency.\n\nThe JavaScript library's sources are available in the repository's `src/` folder.\n\n<https://github.com/timdream/wordcloud2.js>\n:::\n\n## R binding\n\nAn R function which returns a htmltools widget created with `htmlwidgets::createWidget()`\n\n```r\nfunction(x, ...) {\n  # R code preparing data/settings\n\n  # Return a HTML widget\n  createWidget(\n    name, # The name of your widget in /inst\n    x, # The data/settings for the widget's JS binding\n    ...\n  )\n}\n```\n\n## R binding\n\n::: {.callout-caution title=\"Follow along!\"}\nUpdate the generated R binding function to:\n\n* Accept a character vector of words.\n* Accept a numeric vector of frequency/weight.\n* Pass these inputs into the htmlwidget via `x`.\n\n\\vspace{1em}\n\nBonus: improve the design by accepting `.data` as the first input, then using tidy evaluation to pass in the words and frequencies from `.data`.\n:::\n\n## JavaScript binding\n\nThe JavaScript code that takes data/settings from R and uses the JS library to create the output.\n\n\\fontsize{10}{10}\\sf\n```js\nHTMLWidgets.widget({\n  name: \"<name>\",\n  type: \"output\",\n  factory: function(el, width, height) {\n    // initialise the JavaScript object from the library here\n    var obj = new <initalise object>;\n    return {\n      renderValue: function(x) {\n        // update the initalised JavaScript object with new data/settings\n      },\n      resize: function(width, height) {\n        // Re-render or otherwise update size when window changes\n      }\n    };\n  }\n});\n```\n\n## JavaScript binding\n\n::: {.callout-caution title=\"Follow along!\"}\nUpdate the generated JavaScript binding to create the wordcloud on the htmlwidgets HTML element `el`.\n\n\\vspace{1em}\n\nHint: a wordcloud is created using `wordcloud2.js` with:\n\n```js\nWordCloud(el, { list: [['foo', 12], ['bar', 6]] } );\n```\n\nHint: The data can be transposed from two separate vectors into the above format with `HTMLWidgets.transposeArray2D([x.words, x.freqs])`\n:::\n\n\n## Create a wordcloud\n\n::: {.callout-caution title=\"Your turn!\"}\nYour wordcloud function is now ready to use, try it out!\n\n\\vspace{1em}\n\nYou can try it with the love words example dataset here:\n\n::: {.cell}\n\n```{.r .cell-code}\nreadr::read_csv(\n  \"https://arp.numbat.space/week11/lovewords.csv\"\n)\n```\n:::\n\n:::\n\n## Use the wordclouds in a shiny app\n\nThe bindings for shiny apps are already created by `htmlwidgets::scaffoldWidget()`, and can be used in shiny like any other UI output and server renderer.\n\n::: {.cell}\n\n```{.r .cell-code}\nwidgetOutput <- function(outputId, width = '100%', height = '400px'){\n  htmlwidgets::shinyWidgetOutput(outputId, 'widget', width, height,\n                                 package = 'package')\n}\n\nrenderWidget <- function(expr, env = parent.frame(), quoted = FALSE) {\n  if (!quoted) { expr <- substitute(expr) } # force quoted\n  htmlwidgets::shinyRenderWidget(expr, widgetOutput, env, quoted = TRUE)\n}\n```\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": null,
    "postProcess": false
  }
}