{
  "hash": "dc20a6da3c5ec5bffdef7ed9bce8383e",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: ETC4500/ETC5450 Advanced&nbsp;R&nbsp;programming\nauthor: \"Week 10: Metaprogramming\"\nformat:\n  presentation-beamer:\n    fontsize: \"14pt,t\"\n    section-titles: false\n    knitr:\n      opts_chunk:\n        dev: \"cairo_pdf\"\n    fig-width: 7.5\n    fig-height: 3.5\n    include-in-header: ../header.tex\n    keep-tex: false\n---\n\n\n\n## Outline\n\n\\vspace*{0.4cm}\n\\tableofcontents\n\n# Metaprogramming\n\n## Metaprogramming\n\nMetaprogramming is *programming* about programming.\n\nIn other words, writing code that can *inspect* and *modify* code.\n\n. . .\n\n::: {.callout-tip title=\"A powerful idea\"}\nUnlike most programming languages, R *embraces* metaprogramming and non-standard evaluation (NSE).\n\nThis powers much of the strange but wonderful interface designs in R and its packages.\n:::\n\n## The rlang package\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(rlang)\n```\n:::\n\n\n\\placefig{13.5}{0.5}{width=2cm}{../screenshots/rlang.png}\n\nA package for writing R code that interacts with R code.\n\n::: {.callout-important title=\"Not a new idea!\"}\nMetaprogramming/NSE doesn't require the rlang package.\n\n\\hspace{1em}\n\nThere are base R equivalents to the functions shown today.\n\n\\hspace{1em}\n\nNSE is widely used in base R (not just in the tidyverse!)\n:::\n\n## Parsing code\n\nEvery time you run code anywhere in R it needs to be 'interpreted' by the parser.\n\nThe parser reads unstructured text (your written code) and interprets it as an expression.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# parse(text = \"seq(1, 10, by = 0.5)\")\nparse_expr(\"seq(1, 10, by = 0.5)\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nseq(1, 10, by = 0.5)\n```\n\n\n:::\n:::\n\n\n\n## Deparsing code\n\nDeparsing takes an expression and converts it back to text.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_seq <- parse_expr(\"seq(1, 10, by = 0.5)\")\nexpr_text(my_seq)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"seq(1, 10, by = 0.5)\"\n```\n\n\n:::\n:::\n\n\nThis can be useful for providing informative error messages, or print output for objects which store expressions.\n\n## Code is data\n\nExpressions (code) can be used like any other data in R.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_seq <- parse_expr(\"seq(1, 10, by = 0.5)\")\nmy_seq\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nseq(1, 10, by = 0.5)\n```\n\n\n:::\n:::\n\n\n<!-- Looks just like the code we wrote, as if nothing happened. -->\n\n\n::: {.cell}\n\n```{.r .cell-code}\nclass(my_seq)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"call\"\n```\n\n\n:::\n:::\n\n\n. . .\n\n\n::: {.cell}\n\n```{.r .cell-code}\neval(my_seq)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1]  1.0  1.5  2.0  2.5  3.0  3.5  4.0  4.5  5.0  5.5  6.0  6.5  7.0  7.5\n[15]  8.0  8.5  9.0  9.5 10.0\n```\n\n\n:::\n:::\n\n\n\n## Inspecting code\n\nR expressions behave exactly like lists\n\n\\fontsize{10}{10}\\sf\n\n::: {.cell}\n\n```{.r .cell-code}\nas.list(my_seq)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[[1]]\nseq\n\n[[2]]\n[1] 1\n\n[[3]]\n[1] 10\n\n$by\n[1] 0.5\n```\n\n\n:::\n:::\n\n\n## Inspecting code\n\nThey can also be subsetted to inspect the functions and arguments.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_seq[[1]]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nseq\n```\n\n\n:::\n\n```{.r .cell-code}\nmy_seq[[\"by\"]]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.5\n```\n\n\n:::\n:::\n\n\n## Modifying code\n\nExpressions can be modified by replacing their elements.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_seq[[\"by\"]] <- 1\nmy_seq\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nseq(1, 10, by = 1)\n```\n\n\n:::\n\n```{.r .cell-code}\neval(my_seq)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1]  1  2  3  4  5  6  7  8  9 10\n```\n\n\n:::\n:::\n\n\n## Looking at code\n\n::: {.callout-caution title=\"Your turn!\"}\nHow do infix operators (like `+`, `*`, and `%in%`) get interpreted by the parser?\n\n\\hspace{1em}\n\nTry to parse `5 + 3 * 7`, and see how the order of operations are represented in the parsed expression.\n\n\\hspace{1em}\n\nBonus: rewrite this expression without infix operators.\n:::\n\n## Abstract syntax trees\n\nThe structure of expressions is commonly known as an abstract syntax tree (AST). We can use `lobstr::ast()` to explore it.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlobstr::ast(f(x, \"y\", 1))\n```\n:::\n\n\n![](../diagrams/expressions/simple.png)\n\n## Abstract syntax trees\n\nMore complicated (nested) code results in a larger/deeper AST.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlobstr::ast(f(g(1, 2), h(3, 4, i())))\n```\n:::\n\n\n![](../diagrams/expressions/complicated.png)\n\n## Abstract syntax trees\n\n::: {.callout-caution title=\"Your turn!\"}\nInspect the AST for the following code:\n\n* `5 + 3 * 7`\n* `mtcars |> select(cyl)`\n* `mtcars |> mutate(wt/hp)`\n\n\\hspace{0.5em}\n\nHow does R structure these expressions?\n\n\\hspace{0.5em}\n\nBonus: does `-2^2` yield 4 or -4? Why?\n:::\n\n## Analysing code\n\nHow would you programmatically analyse code from hundreds of packages?\n\n\n* Regular expressions on the source code? Maybe...\n* Traverse the parsed source code's AST? Yes!\n\n<!-- Consider a project which analyses the code in R packages. The code is now your dataset for this project! -->\n\n<!-- We could use regular expressions to explore the source code, however it is better to parse the code and explore the AST. -->\n\nThis however can be tricky, requiring recursive algorithms that explore the AST using breadth/depth first search (BFS/DFS).\n\n\n## Coding code\n\nYou can also write code that creates code. For this we use the `call2()` function\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# call(\"seq\", 1, 10, by = 0.5)\ncall2(\"seq\", 1, 10, by = 0.5)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nseq(1, 10, by = 0.5)\n```\n\n\n:::\n:::\n\n\n. . .\n\n::: {.callout-important title=\"parse_expr() or call2()?\"}\nYou might be tempted to `parse()` code that you `paste()` together, but this is unsafe and unreliable! Why?\n:::\n\n\n## Coding code\n\n::: {.callout-note title=\"After the break...\"}\nRecall in week 8 (shiny) I shared this function:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nreact <- function(e) new_function(alist(), expr(eval(!!enexpr(e))))\n```\n:::\n\n\nNext we'll learn how it uses NSE to change how code runs.\n:::\n\n\n\n# (Non-)standard evaluation\n\n## Code evaluation\n\n::: {.callout-note icon=false title=\"Standard evaluation\"}\n* The code and environment is unchanged.\n* The result is evaluated as expected.\n:::\n\n. . .\n\n::: {.callout-note icon=false title=\"Non-standard evaluation (NSE)\"}\n* The code and/or the environment is changed.\n* Leading to the evaluated result changing.\n:::\n\n\n## Standard or non-standard evaluation?\n\n::: {.callout-caution title=\"Your turn!\"}\nDo the following functions use standard evaluation or NSE?\n\n::: {.incremental}\n\n* `library(rlang)`\n* `a + b * c`\n* `mtcars |> select(cyl)`\n* `read_csv(\"data/study.csv\")`\n* `ggplot() + geom_line()`\n* `mtcars |> mutate(wt/hp)`\n* `with(mtcars, wt/hp)`\n:::\n\n:::\n\n## The building blocks of code evaluation\n\nThere are four building blocks used in evaluating code.\n\n* **Constants**: A specific value like `1` or `\"data/study.csv\"`.\n* **Symbols**: A name of an object, like `pi`.\n* **Expressions**: Code structured as an AST.\n* **Environments**: The place where named objects are found.\n\n. . .\n\n::: {.callout-caution title=\"Question?\"}\n\nHow are these building blocks used together to construct and evaluate code?\n\n:::\n\n## The building blocks of code evaluation\n\nIn `rlang`, we have three main building block functions:\n\n* `sym(\"pi\")`: a symbol/name like `pi`\n* `expr(1/pi)`: an expression for `1/pi`\n* `quo(1/pi)`: a *quosure* (expression **and** environment)\n\n. . .\n\n::: {.callout-caution title=\"Follow along!\"}\n\nUse `call2()` and these building blocks to construct and evaluate `mtcars |> mutate(wt/hp)`.\n\nHint: recall that `x |> f(y)` is parsed as `f(x, y)`.\n\n:::\n\n## The building blocks of code evaluation\n\n::: {.callout-caution title=\"Your turn!\"}\n\nSpot the difference.\n\nHow do the results of the following functions differ?\n\n* `sym(\"2 * pi\")`\n* `expr(2 * pi)`\n* `quo(2 * pi)`\n:::\n\n## Capturing code\n\nMore often than not, NSE involves capturing user code that was used in your function. This is done with `en*()` functions:\n\n* `ensym(x)`: capture a symbol\n* `enexpr(x)`: capture an expression\n* `enquo(x)`: capture a quosure\n\n. . .\n\nThese must be used inside functions, for example:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncapture_expr <- function(x) {\n  enexpr(x)\n}\ncapture_expr(1/pi)\n```\n:::\n\n\n## Unquoting (bang-bang!!)\n\nWhy doesn't the following code work?\n\n\\fontsize{10}{10}\\sf\n\n::: {.cell}\n\n```{.r .cell-code}\nlog_expr <- function(x) {\n  # Capture expression\n  x <- enexpr(x)\n  # Return new expression with log()\n  expr(log(x))\n}\nlog_expr(1/pi)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nlog(x)\n```\n\n\n:::\n:::\n\n\n## Unquoting (bang-bang!!)\n\nTo use captured code in our functions, we need to unquote it.\n\n\\fontsize{10}{10}\\sf\n\n::: {.cell}\n\n```{.r .cell-code}\nlog_expr <- function(x) {\n  # Capture expression\n  x <- enexpr(x)\n  # Return new expression with log()\n  expr(log(!!x))\n}\nlog_expr(1/pi)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nlog(1/pi)\n```\n\n\n:::\n:::\n\n\n\\fontsize{14}{14}\\sf\n\n`expr(log(!!x))` will create an expression (`expr()`) that replaces `x` with its value (`1/pi`).\n\n<!-- ::: {.callout-caution title=\"Your turn!\"} -->\n\n<!-- How did the `react()` function capture user expressions and unquote them to produce NSE? -->\n\n<!-- ```{r} -->\n<!-- react <- function(e) new_function(alist(), expr(eval(!!enexpr(e)))) -->\n<!-- ``` -->\n\n<!-- *Hint*: focus on the expression `expr(eval(!!enexpr(e)))`. -->\n<!-- ::: -->\n\n## Unquoting (bang-bang!!)\n\n::: {.callout-tip title=\"Unquoting in analysis\"}\n\nUnquoting replaces the object's name with its value.\n\nThis is also useful when using NSE functions.\n:::\n\nHow can `!!` be useful with dplyr?\n\n## Unquoting (bang-bang!!)\n\nSuppose we wanted to programmatically `filter()` `mtcars$cyl`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncyl <- 4\nmtcars |>\n  filter(cyl == cyl)\n```\n:::\n\n\nWhat's the problem? How can unquoting help?\n\n\n<!-- ```{r} -->\n<!-- #| eval: false -->\n<!-- power <- 2 -->\n<!-- library(dplyr) -->\n<!-- tibble(power = c(3923, 4436, 4806, 4418), error = c(-477, 36, 406, 18)) |> -->\n<!--   summarise(rmse = mean(error^power)^(1/power)) -->\n<!-- ``` -->\n\n\n## Embracing inputs ({{curly-curly}})\n\nThe pattern `!!enquo(x)` is so often in functions that it has a special shortcut known as 'embrace' or 'curly-curly'. The code `{{x}}` is identical to `!!enquo(x)`.\n\nConsider this function for summarising a value's range:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvar_summary <- function(data, var) {\n  data |>\n    summarise(n = n(), min = min({{ var }}), max = max({{ var }}))\n}\nmtcars |>\n  group_by(cyl) |>\n  var_summary(mpg)\n```\n:::\n\n\nWhy is `enquo()` important here?\n\n## Unquote-splicing (bang-bang-bang!!!)\n\nIt is sometimes useful to unquote multiple code elements across multiple arguments of a function.\n\nThis is done with unquote-splicing using `!!!` on a list of symbols, expressions, or quosures.\n\n. . .\n\nA list symbols, expressions, or quosures can be:\n\n* created with `syms()`, `exprs()`, `quos()`\n* captured with `ensyms()`, `enexprs()`, `enquos()`\n\nThis is often used to capture, modify and pass on dots (`...`).\n\n## Unquote-splicing (bang-bang-bang!!!)\n\nFor example, the `var_summary()` function can be extended to accept multiple variables (or expressions) via dots (`...`).\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvar_summaries <- function(data, ...) {\n  vars <- enquos(...)\n  .min <- purrr::map(vars, ~ expr(min(!!.)))\n  .max <- purrr::map(vars, ~ expr(max(!!.)))\n  data |>\n    summarise(n = n(), !!!.min, !!!.max)\n}\nmtcars |>\n  group_by(cyl) |>\n  var_summaries(mpg, wt)\n```\n:::\n\n\n## Tidy dots (:=)\n\nTidy dots (`:=`) allow the argument names to be unquoted too.\n\nFor example:\n\n\\fontsize{10}{10}\\sf\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_df <- function(x) {\n  tibble(!!expr_text(enexpr(x)) := x * 2)\n}\nmy_var <- 10\nmy_df(my_var)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1 Ã— 1\n  my_var\n   <dbl>\n1     20\n```\n\n\n:::\n:::\n\n\nYou can alternatively use `!!!` with a named list.\n\n# Tidy evaluation\n\n## Tidy evaluation\n\nTidy evaluation refers to the use of NSE in the tidyverse to make data analysis easier.\n\nNSE is used widely across tidyverse packages, but at the same time it is used sparingly.\n\n::: {.callout-caution title=\"Your turn!\"}\n\n**Question**\n\nWhere have you seen NSE used in tidyverse packages?\n:::\n\n## Tidy evaluation\n\nTidy evaluation searches the variables of the data first, followed by the search path of the user's environment.\n\nThis is a type of NSE, since it changes the environment in which code is ran.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmtcars |>\n  mutate(mpg/wt)\n```\n:::\n\n\n`mpg/wt` would ordinarily error since `mpg` and `wt` aren't found, but `mutate()` uses NSE to first search the dataset.\n\n## Tidy evaluation\n\nThis is accomplished using `eval_tidy()`, with the arguments:\n\n* `expr`: The expression (code) to evaluate\n* `data`: The dataset 'mask' to search first\n* `env`: The environment to search next.\n\nUnlike `eval()`, this will:\n\n* Respect the environments of quosures\n* Attach *pronouns* for `.data` and `.env`\n\n## Tidy evaluation\n\nWe can use `eval_tidy()` to create a simple `dplyr::mutate()` function variant.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_mutate <- function(.data, mutation) {\n  mutation <- enquo(mutation)\n  result <- eval_tidy(mutation, data = .data, env = caller_env())\n  .data[[as_label(mutation)]] <- result\n  .data\n}\nmtcars |>\n  my_mutate(mpg/wt)\n```\n:::\n\n\n**Question**: What features are missing in our function compared to `dplyr::mutate()`?\n\n## tidyselect\n\nThe tidyselect package is useful for selecting variables from a dataset with NSE.\n\nYou almost certainly have used it in the tidyverse without knowing.\n\nIt powers column selection in:\n\n* `dplyr` for `select()`, `across()`, and more.\n* `tidyr` for almost everything.\n\n## tidyselect\n\nIt enables variable selection with a domain specific language (DSL), which uses NSE to identify columns with:\n\n* `var1:var10`\n* `matches(\"x.\\\\d\")`\n* `all_of(<chr>)`\n* `where(<fn>)`\n\n## tidyselect\n\nIf you need tidy column selection, simply import and use `tidyselect::eval_select()`.\n\n\\fontsize{10}{10}\\sf\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyselect)\nx <- expr(mpg:cyl)\neval_select(x, mtcars)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nmpg cyl \n  1   2 \n```\n\n\n:::\n:::\n\n\n\\fontsize{14}{14}\\sf\n\nThis function returns the column numbers that were selected.\n\n\n## tidyselect\n\nPutting it all together, we can create our own `dplyr::select()` function variant.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_select <- function(.data, cols) {\n  cols <- eval_select(enexpr(cols), .data)\n  .data[cols]\n}\nmy_select(mtcars, c(mpg, wt, vs:carb))\n```\n:::\n\n\n::: {.callout-caution title=\"Your turn!\"}\nModify this function to instead accept the selected columns via the dots (`...`), just like `dplyr::select()` does.\n:::\n\n\n## Software design\n\nNSE is a powerful tool for software design.\n\n\\vspace{2em}\n\n. . .\n\nBut once again, with great power...\n\n. . .\n\n\\qquad\\hspace{6em}... comes great responsibility!\n\n## Tidyverse design principles\n\nNotice how little NSE the tidyverse uses to great effect.\n\nA lot of thought has gone into designing the tidyverse, which mostly uses standard evaluation: https://design.tidyverse.org/\n\n. . .\n\n\n::: {.callout-tip title=\"A design compromise\"}\nWhile very appreciated by users, NSE introduces a lot of complexity when programming with tidyverse packages.\n:::\n\n## Software design with NSE\n\nIn most cases you shouldn't add NSE to your package.\n\n. . .\n\n::: {.callout-important title=\"Why?\"}\nNSE can be incredibly confusing for users!\n\nCode might work outside your function, but be completely different when used inside it.\n:::\n\n. . .\n\nUnderstanding NSE however is very useful for advanced use of tidyverse packages in non-interactive contexts.\n\n## Software design with NSE\n\nIf you must use NSE, you should:\n\n* Use it sparingly\n* Be consistent\n* Clearly document it\n* Get a lot of design benefit from it\n\n  (not just for slightly less typing!)\n",
    "supporting": [
      "slides_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}