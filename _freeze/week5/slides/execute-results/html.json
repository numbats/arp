{
  "hash": "1d5e27423a92f0dd51737b965eb8dc1c",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: ETC4500/ETC5450 Advanced&nbsp;R&nbsp;programming\nauthor: \"Week 5: Functional programming\"\nformat:\n  presentation-beamer:\n    fontsize: \"14pt,t\"\n    section-titles: false\n    knitr:\n      opts_chunk:\n        dev: \"cairo_pdf\"\n    fig-width: 7.5\n    fig-height: 3.5\n    include-in-header: ../header.tex\n    keep-tex: true\n---\n\n\n\n## Outline\n\n\\vspace*{0.4cm}\n\\tableofcontents\n\n\n# Programming paradigms\n\n## Programming paradigms\n\nR code is typically structured using these paradigms:\n\n* Functional programming\n* Object-oriented programming\n* Literate programming\n* Reactive programming\n\nOften several paradigms used together to solve a problem.\n\n## Programming paradigms\n\n::: {.callout-note icon=false title=\"Functional programming (W5; today!)\"}\n* Functions are created and used like any other object.\n* Output should only depend on the function's inputs.\n:::\n\n. . .\n\n::: {.callout-note icon=false title=\"Literate programming (W6)\"}\n* Natural language is interspersed with code.\n* Aimed at prioritising documentation/comments.\n* Now used to create reproducible reports/documents.\n:::\n\n## Programming paradigms\n\n::: {.callout-note icon=false title=\"Reactive programming (W7)\"}\n* Objects are expressed using code based on inputs.\n* When inputs change, the object's value updates.\n:::\n\n. . .\n\n::: {.callout-note icon=false title=\"Object-oriented programming (W8 - W9)\"}\n* Functions are associated with object types.\n* Methods of the same 'function' produce object-specific output.\n:::\n\n# Functional programming\n\n## Functional programming\n\nR is commonly considered a 'functional' programming language - and so far we have used functional programming.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsquare <- function(x) {\n  return(x^2)\n}\nsquare(8)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 64\n```\n\n\n:::\n:::\n\n\nThe `square` function is an object like any other in R.\n\n## Functions are objects\n\nR functions can be printed,\n\n\n::: {.cell}\n\n```{.r .cell-code}\nprint(square)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nfunction (x) \n{\n    return(x^2)\n}\n```\n\n\n:::\n:::\n\n\n. . .\n\ninspected,\n\n\n::: {.cell}\n\n```{.r .cell-code}\nformals(square)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$x\n```\n\n\n:::\n:::\n\n\n## Functions are objects\n\nput in a list,\n\n\\fontsize{10}{10}\\sf\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_functions <- list(square, sum, min, max)\nmy_functions\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[[1]]\nfunction (x) \n{\n    return(x^2)\n}\n\n[[2]]\nfunction (..., na.rm = FALSE)  .Primitive(\"sum\")\n\n[[3]]\nfunction (..., na.rm = FALSE)  .Primitive(\"min\")\n\n[[4]]\nfunction (..., na.rm = FALSE)  .Primitive(\"max\")\n```\n\n\n:::\n:::\n\n\n## Functions are objects\n\nused within lists,\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_functions[[1]](8)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 64\n```\n\n\n:::\n:::\n\n\n. . .\n\nbut they can't be subsetted!\n\n\\fontsize{10}{10}\\sf\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsquare$x\n```\n\n::: {.cell-output .cell-output-error}\n\n```\nError in square$x: object of type 'closure' is not subsettable\n```\n\n\n:::\n:::\n\n\n## Handling input types\n\nFunctional programming handles different input types using control flow. The same code is ran regardless of object type.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsquare <- function(x) {\n  if(!is.numeric(x)) {\n    stop(\"`x` needs to be numeric\")\n  }\n  return(x^2)\n}\n```\n:::\n\n\n. . .\n\n::: {.callout-tip}\n## Later in the semester...\n\nWe will see object-oriented programming, which handles different input types using different functions (methods)!\n:::\n\n## What are functions?\n\nA function is comprised of three components:\n\n* The arguments/inputs (`formals()`)\n* The body/code (`body()`)\n* The environment (`environment()`)\n\n. . .\n\n::: {.callout-caution title=\"Your turn!\"}\nUse these functions to take a closer look at `square()`.\n\nTry modifying the function's formals/body/env with `<-`.\n:::\n\n## Functional programming\n\nSince functions are like any other object, they can also be:\n\n* **inputs** to functions\n\n::: {.callout-tip title=\"Extensible design with function inputs\"}\nUsing function inputs can improve your package's design!\n\nRather than limiting users to a few specific methods, allow them to use and write any method with functions.\n:::\n\n\n## Function arguments\n\nConsider a function which calculates accuracy measures:\n\n\n::: {.cell}\n\n```{.r .cell-code}\naccuracy <- function(e, measure, ...) {\n  if (measure == \"mae\") {\n    mean(abs(e), ...)\n  } else if (measure == \"rmse\") {\n    sqrt(mean(e^2, ...))\n  } else {\n    stop(\"Unknown accuracy measure\")\n  }\n}\n```\n:::\n\n\n::: {.callout-tip title=\"Improving the design\"}\nThis function is limited to only computing MAE and RMSE.\n:::\n\n## Function arguments\n\nUsing function operators allows any measure to be used.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nMAE <- function(e, ...) mean(abs(e), ...)\nRMSE <- function(e, ...) sqrt(mean(e^2, ...))\naccuracy <- function(e, measure, ...) {\n  ???\n}\naccuracy(rnorm(100), measure = RMSE)\n```\n:::\n\n\n::: {.callout-caution title=\"Your turn!\"}\nComplete the accuracy function to calculate accuracy statistics based on the function passed in to `measure`.\n:::\n\n## Functional programming\n\nSince functions are like any other object, they can also be:\n\n* **inputs** to functions\n\n* **outputs** of functions\n\n::: {.callout-tip title=\"Functions making functions?\"}\nThese functions are known as *function factories*.\n\nWhere have you seen a function that creates a function?\n:::\n\n## Function factories\n\nLet's generalise `square()` to raise numbers to any power.\n\n\\fontsize{10}{10}\\sf\n\n\n::: {.cell}\n\n```{.r .cell-code}\npower <- function(x, exp) {\n  x^exp\n}\npower(8, exp = 2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 64\n```\n\n\n:::\n\n```{.r .cell-code}\npower(8, exp = 3)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 512\n```\n\n\n:::\n:::\n\n\n::: {.callout-tip title=\"Starting a factory\"}\nWhat if the function returned a function instead?\n:::\n\n## Function factories\n\n\\fontsize{10}{10}\\sf\n\n\n::: {.cell}\n\n```{.r .cell-code}\npower_factory <- function(exp) {\n  # R is lazy and won't look at exp unless we ask it to\n  force(exp)\n  # Return a function, which finds exp from this environment\n  function(x) {\n    x^exp\n  }\n}\nsquare <- power_factory(exp = 2)\nsquare(8)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 64\n```\n\n\n:::\n:::\n\n\n. . .\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncube <- power_factory(exp = 3)\ncube(8)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 512\n```\n\n\n:::\n:::\n\n\n## Function factories\n\nConsider this function to calculate plot breakpoints of vectors.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbreakpoints <- function(x, n.breaks) {\n  seq(min(x), max(x), length.out = n.breaks)\n}\n```\n:::\n\n\n::: {.callout-caution title=\"Your turn!\"}\nConvert this function into a function factory.\n\nIs it better to create functions via `x` or `n.breaks`?\n:::\n\n# Functional problem solving\n\n## Split, apply, combine\n\nMany problems can be simplified/solved using this process:\n\n* split (break the problem into smaller parts)\n* apply (solve the smaller problems)\n* combine (join solved parts to solve original problem)\n\n. . .\n\nThis technique applies to both\n\n* writing functions (rewriting a function into sub-functions)\n* working with data (same function across groups or files)\n\n<!-- ## Functionals -->\n\n<!-- ::: {.callout-note title=\"Functionals\"} -->\n<!-- *Functionals* use function inputs and returns vectors.  -->\n<!-- ::: -->\n\n<!-- ```{r} -->\n<!-- randomise <- function(f) f(runif(1e3)) -->\n<!-- randomise(mean) -->\n<!-- randomise(sum) -->\n<!-- ``` -->\n\n## data |> group_by() |> summarise()\n\nAn example of split-apply-combine being used to work with data is when `group_by()` and `summarise()` are used together.\n\n. . .\n\n* split: `group_by()` splits up the data into groups\n* apply: your `summarise()` code calculates a single value\n* combine: `summarise()` combines the results into a vector\n\n. . .\n\n\\fontsize{10}{10}\\sf\n\n:::: {.columns}\n\n::: {.column width=\"50%\"}\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(dplyr)\nmtcars |>\n  group_by(cyl) |>\n  summarise(mean(mpg))\n```\n:::\n\n:::\n\n::: {.column width=\"50%\"}\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3 Ã— 2\n    cyl `mean(mpg)`\n  <dbl>       <dbl>\n1     4        26.7\n2     6        19.7\n3     8        15.1\n```\n\n\n:::\n:::\n\n:::\n\n::::\n\n\n## Split-apply-combine for vectors and lists\n\nThe same idea can be used for calculations on vectors.\n\n. . .\n\nThere are two main implementations we consider:\n\n* base R: The `*apply()` functions\n* purrr: The `map*()` functions\n\n. . .\n\nWe will use purrr and but I'll also share the base R equivalent.\n\n## for or map?\n\nLet's `square()` a vector of numbers with a for loop.\n\n\\fontsize{10}{10}\\sf\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- c(1, 3, 8)\nx2 <- numeric(length(x))\nfor (i in seq_along(x)) {\n  x2[i] <- square(x[i])\n}\nx2\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  1  9 64\n```\n\n\n:::\n:::\n\n\n. . .\n\n\\fontsize{13}{14}\\sf\n::: {.callout-tip title=\"Vectorisation?\"}\nOf course `square()` is vectorised, so we should use `square(x)`. Other functions like `lm()` or `read.csv()` are not!\n:::\n\n## for or map?\n\nInstead using `map()` we get...\n\n\\fontsize{13}{14}\\sf\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(purrr)\nx <- c(1, 3, 8)\nmap(x, square) # lapply(x, square)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[[1]]\n[1] 1\n\n[[2]]\n[1] 9\n\n[[3]]\n[1] 64\n```\n\n\n:::\n:::\n\n\n## Mapping vectors\n\nThe same result, but it has been combined differently!\n\n![](../diagrams/functionals/map.png){fig-align=\"center\"}\n\n## Mapping vectors\n\nTo combine the results into a vector rather than a list, we instead use `map_vec()` to combine results into a vector.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(purrr)\nx <- c(1, 3, 8)\nmap_vec(x, square) # vapply(x, square, numeric(1L))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  1  9 64\n```\n\n\n:::\n:::\n\n\n## for or map\n\n::: {.callout-tip title=\"Advantages of map\"}\n* Less coding (less bugs!)\n* Easier to read and understand.\n:::\n\n. . .\n\n::: {.callout-important title=\"Disadvantages of map\"}\n* Less control over loop\n* Cannot solve sequential problems\n:::\n\n## Functional mapping\n\nRecall `group_by()` and `summarise()` from dplyr:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmtcars |>\n  group_by(cyl) |>\n  summarise(mean(mpg))\n```\n:::\n\n\n::: {.callout-caution title=\"Your turn!\"}\nUse `split()` and `map_vec()` to achieve a similar result.\n\n*Hint: `split(mtcars$mpg, mtcars$cyl)` creates a list that splits `mtcars$mpg` by each value of `mtcars$cyl`.*\n:::\n\n## Anonymous mapper functions\n\n<!-- Often the function that you map is more complicated than `mean`, and you might need to specify where the mapped vector is used. -->\n\nSuppose we want to separately model `mpg` for each `cyl`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlm(mpg ~ disp + hp + drat + wt, mtcars[mtcars$cyl == 4,])\nlm(mpg ~ disp + hp + drat + wt, mtcars[mtcars$cyl == 6,])\nlm(mpg ~ disp + hp + drat + wt, mtcars[mtcars$cyl == 8,])\n```\n:::\n\n\n## Anonymous mapper functions\n\nWe can split the data by `cyl` with `split()`,\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmtcars_cyl <- split(mtcars, mtcars$cyl)\n```\n:::\n\n\nbut `map(mtcars_cyl, lm, mpg ~ disp + hp + drat + wt)` won't work - why?\n\n. . .\n\n::: {.callout-important title=\"Difficult to map\"}\nUsing `map(mtcars_cyl, lm)` will apply `lm(mtcars_cyl[i])`.\n\nThe mapped vector is always used as the first argument!\n:::\n\n## Anonymous mapper functions\n\nWe can write our own functions!\n\n\\fontsize{10}{10}\\sf\n\n::: {.cell}\n\n```{.r .cell-code}\nmtcars_lm <- function(.) lm(mpg ~ disp + hp + drat + wt, data = .)\nmap(mtcars_cyl, mtcars_lm)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$`4`\n\nCall:\nlm(formula = mpg ~ disp + hp + drat + wt, data = .)\n\nCoefficients:\n(Intercept)         disp           hp         drat           wt  \n    52.5195      -0.0629      -0.0760      -1.4422      -3.1001  \n\n\n$`6`\n\nCall:\nlm(formula = mpg ~ disp + hp + drat + wt, data = .)\n\nCoefficients:\n(Intercept)         disp           hp         drat           wt  \n   15.12328      0.04363      0.00252      2.43188     -3.98026  \n\n\n$`8`\n\nCall:\nlm(formula = mpg ~ disp + hp + drat + wt, data = .)\n\nCoefficients:\n(Intercept)         disp           hp         drat           wt  \n   2.68e+01     6.59e-05    -1.35e-02    -4.53e-02    -2.19e+00  \n```\n\n\n:::\n:::\n\n\n## Anonymous mapper functions\n\nOr use `~ body` to create anonymous functions.\n\n\\fontsize{10}{10}\\sf\n\n::: {.cell}\n\n```{.r .cell-code}\n# lapply(mtcars_cyl, \\(.) lm(mpg ~ disp + hp + drat + wt, data = .))\nmap(mtcars_cyl, ~ lm(mpg ~ disp + hp + drat + wt, data = .))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$`4`\n\nCall:\nlm(formula = mpg ~ disp + hp + drat + wt, data = .)\n\nCoefficients:\n(Intercept)         disp           hp         drat           wt  \n    52.5195      -0.0629      -0.0760      -1.4422      -3.1001  \n\n\n$`6`\n\nCall:\nlm(formula = mpg ~ disp + hp + drat + wt, data = .)\n\nCoefficients:\n(Intercept)         disp           hp         drat           wt  \n   15.12328      0.04363      0.00252      2.43188     -3.98026  \n\n\n$`8`\n\nCall:\nlm(formula = mpg ~ disp + hp + drat + wt, data = .)\n\nCoefficients:\n(Intercept)         disp           hp         drat           wt  \n   2.68e+01     6.59e-05    -1.35e-02    -4.53e-02    -2.19e+00  \n```\n\n\n:::\n:::\n\n\n## Mapping mapping mapping\n\nHow would you then get the coefficients from all 3 models?\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# mtcars_cyl |> lapply(\\(.) lm(mpg ~ disp + hp + drat + wt, data = .))\nmtcars_cyl |>\n  map(~ lm(mpg ~ disp + hp + drat + wt, data = .))\n```\n:::\n\n\n. . .\n\n::: {.callout-tip title=\"Solution\"}\n\n\\fontsize{10}{10}\\sf\n\n::: {.cell}\n\n```{.r .cell-code}\n# lapply(mtcars_cyl, \\(.) lm(mpg ~ disp + hp + drat + wt, data = .))\nmtcars_cyl |>\n  map(~ lm(mpg ~ disp + hp + drat + wt, data = .)) |>\n  map(coef)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$`4`\n(Intercept)        disp          hp        drat          wt \n    52.5195     -0.0629     -0.0760     -1.4422     -3.1001 \n\n$`6`\n(Intercept)        disp          hp        drat          wt \n   15.12328     0.04363     0.00252     2.43188    -3.98026 \n\n$`8`\n(Intercept)        disp          hp        drat          wt \n   2.68e+01    6.59e-05   -1.35e-02   -4.53e-02   -2.19e+00 \n```\n\n\n:::\n:::\n\n:::\n\n\n## Mapping arguments\n\nAny arguments after your function are passed to all functions.\n\n![](../diagrams/functionals/map-arg.png){fig-align=\"center\"}\n\n## Mapping arguments\n\nThis works by passing through `...` to the function.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- list(1:5, c(1:10, NA))\nmap_dbl(x, ~ mean(.x, na.rm = TRUE))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 3.0 5.5\n```\n\n\n:::\n\n```{.r .cell-code}\nmap_dbl(x, mean, na.rm = TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 3.0 5.5\n```\n\n\n:::\n:::\n\n\n## Mapping arguments\n\nThese additional arguments are not decomposed / mapped.\n\n![](../diagrams/functionals/map-arg-recycle.png){fig-align=\"center\"}\n\n## Mapping multiple arguments\n\nIt is often useful to map multiple arguments.\n\n![](../diagrams/functionals/map2.png){fig-align=\"center\"}\n\n## Mapping multiple arguments\n\n\n::: {.cell}\n\n```{.r .cell-code}\nxs <- map(1:8, ~ ifelse(runif(10) > 0.8, NA, runif(10)))\nmap_vec(xs, mean, na.rm = TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.455 0.535 0.439 0.389 0.332 0.641 0.556 0.483\n```\n\n\n:::\n:::\n\n\n. . .\n\n\n::: {.cell}\n\n```{.r .cell-code}\nws <- map(1:8, ~ rpois(10, 5) + 1)\nmap2_vec(xs, ws, weighted.mean, na.rm = TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.413 0.568 0.407 0.376 0.371 0.669 0.526 0.490\n```\n\n\n:::\n:::\n\n\n\n## Mapping multiple arguments\n\n![](../diagrams/functionals/map2-arg.png){fig-align=\"center\"}\n\n## Mapping many arguments\n\nIt is also possible to map any number of inputs with `pmap`.\n\n\\fontsize{10}{10}\\sf\n\n::: {.cell}\n\n```{.r .cell-code}\nn <- 1:3\nmin <- c(0, 10, 100)\nmax <- c(1, 100, 1000)\npmap(list(n, min, max), runif) # .mapply(runif, list(n, min, max), list())\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[[1]]\n[1] 0.802\n\n[[2]]\n[1] 75.6 42.9\n\n[[3]]\n[1] 270 588 223\n```\n\n\n:::\n:::\n\n\n## Mapping many arguments\n\n![](../diagrams/functionals/pmap-3.png){fig-align=\"center\"}\n\n## Parallel mapping\n\nSplit-apply-combine problems are *embarrassingly parallel*.\n\n. . .\n\nThe furrr package (future + purrr) makes it easy to use `map()` in parallel, providing `future_map()` variants.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(furrr)\nplan(multisession, workers = 4)\nfuture_map_dbl(xs, mean, na.rm = TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.455 0.535 0.439 0.389 0.332 0.641 0.556 0.483\n```\n\n\n:::\n\n```{.r .cell-code}\nfuture_map2_dbl(xs, ws, weighted.mean, na.rm = TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.413 0.568 0.407 0.376 0.371 0.669 0.526 0.490\n```\n\n\n:::\n:::\n\n\n## Reduce vectors to single values\n\nSometimes you want to collapse a vector, reducing it to a single value. `reduce()` always returns a vector of length 1.\n\n\\fontsize{10}{10}\\sf\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- sample(1:100, 10)\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] 65  5 63 14 22 83 42 18 64 88\n```\n\n\n:::\n\n```{.r .cell-code}\nsum(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 464\n```\n\n\n:::\n\n```{.r .cell-code}\n# Alternative to sum()\nreduce(x, `+`) # Reduce(`+`, x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 464\n```\n\n\n:::\n:::\n\n\n## Reduce vectors to single values\n\nThe result from the function is re-used as the first argument.\n\n![](../diagrams/functionals/reduce.png){fig-align=\"center\"}\n\n## Reduce vectors to single values\n\n::: {.callout-caution title=\"Your turn!\"}\nWe're studying the letters in 3 bowls of alphabet soup.\n\n![](../diagrams/alphabet-soup.jpg){height=50%}\n:::\n\n\n## Reduce vectors to single values\n\n::: {.callout-caution title=\"Your turn!\"}\nWe're studying the letters in 3 bowls of alphabet soup.\n\nUse `reduce()` to find the letters were in all bowls of soup!\n\nAre all letters found in the soups?\n\n\\fontsize{10}{10}\\sf\n\n::: {.cell}\n\n```{.r .cell-code}\nalphabet_soup <- map(c(10,24,13), sample, x=letters, replace=TRUE)\nalphabet_soup\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[[1]]\n [1] \"q\" \"w\" \"y\" \"l\" \"u\" \"l\" \"g\" \"s\" \"i\" \"r\"\n\n[[2]]\n [1] \"r\" \"m\" \"w\" \"k\" \"l\" \"e\" \"k\" \"x\" \"i\" \"h\" \"i\" \"p\" \"a\" \"e\" \"u\" \"g\" \"k\"\n[18] \"d\" \"h\" \"y\" \"f\" \"v\" \"b\" \"q\"\n\n[[3]]\n [1] \"v\" \"e\" \"j\" \"s\" \"f\" \"r\" \"l\" \"u\" \"z\" \"e\" \"m\" \"y\" \"k\"\n```\n\n\n:::\n:::\n\n\n:::\n\n## Functional adverbs\n\npurrr also offers many *adverbs*, which modify a function.\n\n::: {.callout-note icon=false title=\"Capturing conditions\"}\n* `possibly(.f, otherwise)`: If the function errors, it will return `otherwise` instead.\n* `safely(.f)`: The function now returns a list with 'result' and 'error', preventing errors.\n* `quietly(.f)`: Any conditions (messages, warnings, printed output) are now captured into a list.\n:::\n\n## Functional adverbs\n\npurrr also offers many *adverbs*, which modify a function.\n\n::: {.callout-note icon=false title=\"Changing results\"}\n* `negate(.f)` will return `!result`.\n:::\n\n::: {.callout-note icon=false title=\"Chaining functions\"}\n* `compose(...)` will chain functions together like a chain of piped functions.\n:::\n\n\n## Functional adverbs\n\npurrr also offers many *adverbs*, which modify a function.\n\n::: {.callout-tip title=\"Functions modifying functions?\"}\nThese functions are all *function factories*!\n\nMore specifically they are known as *function operators* since both the input and output is a function.\n\n`memoise::memoise()` is also a *function operator*.\n:::\n\n\n<!-- These are function factories! -->\n\n<!-- ## How does it work? -->\n\n<!-- ```{r, eval = FALSE} -->\n<!-- simple_map <- function(x, f, ...) { -->\n<!--   out <- vector(\"list\", length(x)) -->\n<!--   for(i in seq_along(x)) { -->\n<!--     out[[i]] <- f(x[[i]], ...) -->\n<!--   } -->\n<!--   out -->\n<!-- } -->\n<!-- ``` -->\n\n\n<!-- 1. purrr/furrr -->\n<!-- 2. functional arguments -->\n<!-- 3. functional outputs -->\n",
    "supporting": [
      "slides_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}